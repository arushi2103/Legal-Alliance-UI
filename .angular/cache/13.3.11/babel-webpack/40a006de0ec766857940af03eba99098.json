{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\n\nconst util_1 = require(\"util\");\n\nconst bson_1 = require(\"./bson\");\n\nconst metrics_1 = require(\"./cmap/metrics\");\n\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\n\nconst constants_1 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst run_command_1 = require(\"./operations/run_command\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst transactions_1 = require(\"./transactions\");\n\nconst utils_1 = require(\"./utils\");\n\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\n\nconst kServerSession = Symbol('serverSession');\n/** @internal */\n\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\n\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\n\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\n\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\n\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n\n    this[_a] = false;\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n\n\n  get id() {\n    return this[kServerSession]?.id;\n  }\n\n  get serverSession() {\n    let serverSession = this[kServerSession];\n\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n\n\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced() {\n    return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n\n\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n\n\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n\n\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n\n\n  endSession(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (_this.inTransaction()) {\n          yield _this.abortTransaction();\n        }\n\n        if (!_this.hasEnded) {\n          const serverSession = _this[kServerSession];\n\n          if (serverSession != null) {\n            // release the server session back to the pool\n            _this.sessionPool.release(serverSession); // Make sure a new serverSession never makes it onto this ClientSession\n\n\n            Object.defineProperty(_this, kServerSession, {\n              value: ServerSession.clone(serverSession),\n              writable: false\n            });\n          } // mark the session as ended, and emit a signal\n\n\n          _this.hasEnded = true;\n\n          _this.emit('ended', _this);\n        }\n      } catch {// spec indicates that we should ignore all errors for `endSessions`\n      } finally {\n        maybeClearPinnedConnection(_this, {\n          force: true,\n          ...options\n        });\n      }\n    })();\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n\n\n  advanceClusterTime(clusterTime) {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n\n    if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && clusterTime.signature.keyId?._bsontype !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n\n\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n\n\n  startTransaction(options) {\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new transactions_1.Transaction({\n      readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,\n      writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,\n      readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n  /**\n   * Commits the currently active transaction in this session.\n   */\n\n\n  commitTransaction() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return endTransactionAsync(_this2, 'commitTransaction');\n    })();\n  }\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n\n\n  abortTransaction() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return endTransactionAsync(_this3, 'abortTransaction');\n    })();\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n\n\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Runs a provided callback within a transaction, retrying either the commitTransaction operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n   * Any callbacks that do not return a Promise will result in undefined behavior.\n   *\n   * @remarks\n   * This function:\n   * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\n   * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\n   * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/developer/quickstart/node-transactions/\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n\n\n  withTransaction(fn, options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const startTime = (0, utils_1.now)();\n      return attemptTransaction(_this4, startTime, fn, options);\n    })();\n  }\n\n}\n\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\n\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n\n  const topology = session.client.topology; // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if (options?.error == null || options?.force) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n\n      if (options?.forceClear) {\n        loadBalancer.s.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(() => null);\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n\n      throw err;\n    }\n\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nconst endTransactionAsync = (0, util_1.promisify)(endTransaction);\n\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(error, result) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n      return callback();\n    }\n\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n\n    if (error instanceof error_1.MongoError) {\n      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult); // per txns spec, must unpin session in this case\n\n          session.unpin({\n            error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error\n        });\n      }\n    }\n\n    callback(error, result);\n  }\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), (error, result) => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n\n    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n\n    commandHandler(error, result);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\n\n\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n\n\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type); // Manual prototype construction to avoid modifying the constructor of this class\n\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n\n}\n\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\n\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n\n\n  acquire() {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n    let session = null; // Try to obtain from session pool\n\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n\n      if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    } // If nothing valid came from the pool make a new one\n\n\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n\n\n  release(session) {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n}\n\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\n\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  } // May acquire serverSession here\n\n\n  const serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n\n    return;\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0; // TODO(NODE-2674): Preserve int64 sent from MongoDB\n\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n\n    return;\n  } // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n\n  return;\n}\n\nexports.applySession = applySession;\n\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/sessions.js"],"names":["_a","Object","defineProperty","exports","value","updateSessionFromResponse","applySession","ServerSessionPool","ServerSession","maybeClearPinnedConnection","ClientSession","util_1","require","bson_1","metrics_1","shared_1","constants_1","error_1","mongo_types_1","execute_operation_1","run_command_1","read_concern_1","read_preference_1","common_1","transactions_1","utils_1","minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","TypedEventEmitter","constructor","client","sessionPool","options","clientOptions","MongoRuntimeError","snapshot","causalConsistency","MongoInvalidArgumentError","hasEnded","explicit","acquire","defaultCausalConsistencyValue","supports","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","assign","transaction","Transaction","id","serverSession","snapshotEnabled","loadBalanced","topology","description","type","TopologyType","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","PINNED","inTransaction","ConnectionPoolMetrics","TXN","CURSOR","unpin","unpinServer","isPinned","endSession","abortTransaction","release","clone","writable","force","advanceOperationTime","greaterThan","advanceClusterTime","_bsontype","signature","hash","keyId","_advanceClusterTime","equals","session","ByteUtils","buffer","incrementTransactionNumber","isActive","startTransaction","MongoCompatibilityError","MongoTransactionError","isCommitted","topologyMaxWireVersion","maxWireVersion","isSharded","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","TxnState","STARTING_TRANSACTION","commitTransaction","endTransactionAsync","toBSON","withTransaction","fn","startTime","now","attemptTransaction","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","calculateDurationInMs","isUnknownTransactionCommitResult","err","isNonDeterministicWriteConcernError","MongoServerError","codeName","has","isMaxTimeMSExpiredError","code","MONGODB_ERROR_CODES","UnsatisfiableWriteConcern","UnknownReplWriteConcern","error","MongoError","hasErrorLabel","MongoErrorLabel","TransientTransactionError","servers","Array","from","s","values","loadBalancer","pool","checkIn","UNPINNED","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","catch","UnknownTransactionCommitResult","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","promise","Promise","reject","isPromiseLike","then","maybeRetryOrThrow","addErrorLabel","promisify","endTransaction","commandName","callback","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeout","maxTimeMS","commandHandler","result","RetryableWriteError","MongoWriteConcernError","recoveryToken","executeOperation","RunAdminCommandOperation","ReadPreference","primary","bypassPinningCheck","Binary","uuidV4","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","prototype","sessions","List","logicalSessionTimeoutMinutes","length","potentialSession","shift","unshift","prune","MongoExpiredSessionError","MongoAPIError","lsid","inTxnOrTxnCommand","isTransactionCommand","isRetryableWrite","willRetryWrite","Long","fromNumber","commandSupportsReadConcern","afterClusterTime","level","ReadConcernLevel","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","document","$clusterTime","_recoveryToken","cursor"],"mappings":"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","sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n    /**\n     * Create a client session.\n     * @internal\n     * @param client - The current client\n     * @param sessionPool - The server session pool (Internal Class)\n     * @param options - Optional settings\n     * @param clientOptions - Optional settings provided when creating a MongoClient\n     */\n    constructor(client, sessionPool, options, clientOptions) {\n        super();\n        /** @internal */\n        this[_a] = false;\n        if (client == null) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n        }\n        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n        }\n        options = options ?? {};\n        if (options.snapshot === true) {\n            this[kSnapshotEnabled] = true;\n            if (options.causalConsistency === true) {\n                throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n            }\n        }\n        this.client = client;\n        this.sessionPool = sessionPool;\n        this.hasEnded = false;\n        this.clientOptions = clientOptions;\n        this.explicit = !!options.explicit;\n        this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n        this[kTxnNumberIncrement] = 0;\n        const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n        this.supports = {\n            // if we can enable causal consistency, do so by default\n            causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n        };\n        this.clusterTime = options.initialClusterTime;\n        this.operationTime = undefined;\n        this.owner = options.owner;\n        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n        this.transaction = new transactions_1.Transaction();\n    }\n    /** The server id associated with this session */\n    get id() {\n        return this[kServerSession]?.id;\n    }\n    get serverSession() {\n        let serverSession = this[kServerSession];\n        if (serverSession == null) {\n            if (this.explicit) {\n                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n            }\n            if (this.hasEnded) {\n                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n            }\n            serverSession = this.sessionPool.acquire();\n            this[kServerSession] = serverSession;\n        }\n        return serverSession;\n    }\n    /** Whether or not this session is configured for snapshot reads */\n    get snapshotEnabled() {\n        return this[kSnapshotEnabled];\n    }\n    get loadBalanced() {\n        return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;\n    }\n    /** @internal */\n    get pinnedConnection() {\n        return this[kPinnedConnection];\n    }\n    /** @internal */\n    pin(conn) {\n        if (this[kPinnedConnection]) {\n            throw TypeError('Cannot pin multiple connections to the same session');\n        }\n        this[kPinnedConnection] = conn;\n        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    }\n    /** @internal */\n    unpin(options) {\n        if (this.loadBalanced) {\n            return maybeClearPinnedConnection(this, options);\n        }\n        this.transaction.unpinServer();\n    }\n    get isPinned() {\n        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n    /**\n     * Ends this session on the server\n     *\n     * @param options - Optional settings. Currently reserved for future use\n     */\n    async endSession(options) {\n        try {\n            if (this.inTransaction()) {\n                await this.abortTransaction();\n            }\n            if (!this.hasEnded) {\n                const serverSession = this[kServerSession];\n                if (serverSession != null) {\n                    // release the server session back to the pool\n                    this.sessionPool.release(serverSession);\n                    // Make sure a new serverSession never makes it onto this ClientSession\n                    Object.defineProperty(this, kServerSession, {\n                        value: ServerSession.clone(serverSession),\n                        writable: false\n                    });\n                }\n                // mark the session as ended, and emit a signal\n                this.hasEnded = true;\n                this.emit('ended', this);\n            }\n        }\n        catch {\n            // spec indicates that we should ignore all errors for `endSessions`\n        }\n        finally {\n            maybeClearPinnedConnection(this, { force: true, ...options });\n        }\n    }\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n    advanceOperationTime(operationTime) {\n        if (this.operationTime == null) {\n            this.operationTime = operationTime;\n            return;\n        }\n        if (operationTime.greaterThan(this.operationTime)) {\n            this.operationTime = operationTime;\n        }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n    advanceClusterTime(clusterTime) {\n        if (!clusterTime || typeof clusterTime !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n        }\n        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n        }\n        if (!clusterTime.signature ||\n            clusterTime.signature.hash?._bsontype !== 'Binary' ||\n            (typeof clusterTime.signature.keyId !== 'bigint' &&\n                typeof clusterTime.signature.keyId !== 'number' &&\n                clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n        ) {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n        }\n        (0, common_1._advanceClusterTime)(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n    equals(session) {\n        if (!(session instanceof ClientSession)) {\n            return false;\n        }\n        if (this.id == null || session.id == null) {\n            return false;\n        }\n        return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n    }\n    /**\n     * Increment the transaction number on the internal ServerSession\n     *\n     * @privateRemarks\n     * This helper increments a value stored on the client session that will be\n     * added to the serverSession's txnNumber upon applying it to a command.\n     * This is because the serverSession is lazily acquired after a connection is obtained\n     */\n    incrementTransactionNumber() {\n        this[kTxnNumberIncrement] += 1;\n    }\n    /** @returns whether this session is currently in a transaction or not */\n    inTransaction() {\n        return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n    startTransaction(options) {\n        if (this[kSnapshotEnabled]) {\n            throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n        }\n        if (this.inTransaction()) {\n            throw new error_1.MongoTransactionError('Transaction already in progress');\n        }\n        if (this.isPinned && this.transaction.isCommitted) {\n            this.unpin();\n        }\n        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n        if ((0, shared_1.isSharded)(this.client.topology) &&\n            topologyMaxWireVersion != null &&\n            topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n        }\n        // increment txnNumber\n        this.incrementTransactionNumber();\n        // create transaction state\n        this.transaction = new transactions_1.Transaction({\n            readConcern: options?.readConcern ??\n                this.defaultTransactionOptions.readConcern ??\n                this.clientOptions?.readConcern,\n            writeConcern: options?.writeConcern ??\n                this.defaultTransactionOptions.writeConcern ??\n                this.clientOptions?.writeConcern,\n            readPreference: options?.readPreference ??\n                this.defaultTransactionOptions.readPreference ??\n                this.clientOptions?.readPreference,\n            maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n        });\n        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n    /**\n     * Commits the currently active transaction in this session.\n     */\n    async commitTransaction() {\n        return endTransactionAsync(this, 'commitTransaction');\n    }\n    /**\n     * Aborts the currently active transaction in this session.\n     */\n    async abortTransaction() {\n        return endTransactionAsync(this, 'abortTransaction');\n    }\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n    toBSON() {\n        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Runs a provided callback within a transaction, retrying either the commitTransaction operation\n     * or entire transaction as needed (and when the error permits) to better ensure that\n     * the transaction can complete successfully.\n     *\n     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n     * Any callbacks that do not return a Promise will result in undefined behavior.\n     *\n     * @remarks\n     * This function:\n     * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\n     * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\n     * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\n     *\n     * Checkout a descriptive example here:\n     * @see https://www.mongodb.com/developer/quickstart/node-transactions/\n     *\n     * @param fn - callback to run within a transaction\n     * @param options - optional settings for the transaction\n     * @returns A raw command response or undefined\n     */\n    async withTransaction(fn, options) {\n        const startTime = (0, utils_1.now)();\n        return attemptTransaction(this, startTime, fn, options);\n    }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n    'CannotSatisfyWriteConcern',\n    'UnknownReplWriteConcern',\n    'UnsatisfiableWriteConcern'\n]);\nfunction hasNotTimedOut(startTime, max) {\n    return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&\n        err.codeName &&\n        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n    return (isMaxTimeMSExpiredError(err) ||\n        (!isNonDeterministicWriteConcernError &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));\n}\nfunction maybeClearPinnedConnection(session, options) {\n    // unpin a connection if it has been pinned\n    const conn = session[kPinnedConnection];\n    const error = options?.error;\n    if (session.inTransaction() &&\n        error &&\n        error instanceof error_1.MongoError &&\n        error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return;\n    }\n    const topology = session.client.topology;\n    // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n    //       to validate that we don't unpin on _all_ errors?\n    if (conn && topology != null) {\n        const servers = Array.from(topology.s.servers.values());\n        const loadBalancer = servers[0];\n        if (options?.error == null || options?.force) {\n            loadBalancer.s.pool.checkIn(conn);\n            conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION\n                ? metrics_1.ConnectionPoolMetrics.TXN\n                : metrics_1.ConnectionPoolMetrics.CURSOR);\n            if (options?.forceClear) {\n                loadBalancer.s.pool.clear({ serviceId: conn.serviceId });\n            }\n        }\n        session[kPinnedConnection] = undefined;\n    }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n    if (err == null || !(err instanceof error_1.MongoServerError)) {\n        return false;\n    }\n    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n        (err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired));\n}\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n    return session.commitTransaction().catch((err) => {\n        if (err instanceof error_1.MongoError &&\n            hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n            !isMaxTimeMSExpiredError(err)) {\n            if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n                return attemptTransactionCommit(session, startTime, fn, options);\n            }\n            if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n        }\n        throw err;\n    });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\n    transactions_1.TxnState.NO_TRANSACTION,\n    transactions_1.TxnState.TRANSACTION_COMMITTED,\n    transactions_1.TxnState.TRANSACTION_ABORTED\n]);\nfunction userExplicitlyEndedTransaction(session) {\n    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options) {\n    session.startTransaction(options);\n    let promise;\n    try {\n        promise = fn(session);\n    }\n    catch (err) {\n        promise = Promise.reject(err);\n    }\n    if (!(0, utils_1.isPromiseLike)(promise)) {\n        session.abortTransaction().catch(() => null);\n        throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n    }\n    return promise.then(() => {\n        if (userExplicitlyEndedTransaction(session)) {\n            return;\n        }\n        return attemptTransactionCommit(session, startTime, fn, options);\n    }, err => {\n        function maybeRetryOrThrow(err) {\n            if (err instanceof error_1.MongoError &&\n                err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&\n                hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n            if (isMaxTimeMSExpiredError(err)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n            }\n            throw err;\n        }\n        if (session.inTransaction()) {\n            return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n        }\n        return maybeRetryOrThrow(err);\n    });\n}\nconst endTransactionAsync = (0, util_1.promisify)(endTransaction);\nfunction endTransaction(session, commandName, callback) {\n    // handle any initial problematic cases\n    const txnState = session.transaction.state;\n    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n        callback(new error_1.MongoTransactionError('No transaction started'));\n        return;\n    }\n    if (commandName === 'commitTransaction') {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n            return;\n        }\n    }\n    else {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n            return;\n        }\n    }\n    // construct and send the command\n    const command = { [commandName]: 1 };\n    // apply a writeConcern if specified\n    let writeConcern;\n    if (session.transaction.options.writeConcern) {\n        writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n    }\n    else if (session.clientOptions && session.clientOptions.writeConcern) {\n        writeConcern = { w: session.clientOptions.writeConcern.w };\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n        writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n    }\n    if (writeConcern) {\n        Object.assign(command, { writeConcern });\n    }\n    if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n    }\n    function commandHandler(error, result) {\n        if (commandName !== 'commitTransaction') {\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            if (session.loadBalanced) {\n                maybeClearPinnedConnection(session, { force: false });\n            }\n            // The spec indicates that we should ignore all errors on `abortTransaction`\n            return callback();\n        }\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n        if (error instanceof error_1.MongoError) {\n            if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) ||\n                error instanceof error_1.MongoWriteConcernError ||\n                isMaxTimeMSExpiredError(error)) {\n                if (isUnknownTransactionCommitResult(error)) {\n                    error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n                    // per txns spec, must unpin session in this case\n                    session.unpin({ error });\n                }\n            }\n            else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n                session.unpin({ error });\n            }\n        }\n        callback(error, result);\n    }\n    if (session.transaction.recoveryToken) {\n        command.recoveryToken = session.transaction.recoveryToken;\n    }\n    // send the command\n    (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n    }), (error, result) => {\n        if (command.abortTransaction) {\n            // always unpin on abort regardless of command outcome\n            session.unpin();\n        }\n        if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n            // SPEC-1185: apply majority write concern when retrying commitTransaction\n            if (command.commitTransaction) {\n                // per txns spec, must unpin session in this case\n                session.unpin({ force: true });\n                command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n                    w: 'majority'\n                });\n            }\n            return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n                session,\n                readPreference: read_preference_1.ReadPreference.primary,\n                bypassPinningCheck: true\n            }), commandHandler);\n        }\n        commandHandler(error, result);\n    });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n    /** @internal */\n    constructor() {\n        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };\n        this.lastUse = (0, utils_1.now)();\n        this.txnNumber = 0;\n        this.isDirty = false;\n    }\n    /**\n     * Determines if the server session has timed out.\n     *\n     * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n     */\n    hasTimedOut(sessionTimeoutMinutes) {\n        // Take the difference of the lastUse timestamp and now, which will result in a value in\n        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n        const idleTimeMinutes = Math.round((((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000) % 3600000) / 60000);\n        return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n    /**\n     * @internal\n     * Cloning meant to keep a readable reference to the server session data\n     * after ClientSession has ended\n     */\n    static clone(serverSession) {\n        const arrayBuffer = new ArrayBuffer(16);\n        const idBytes = Buffer.from(arrayBuffer);\n        idBytes.set(serverSession.id.id.buffer);\n        const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n        // Manual prototype construction to avoid modifying the constructor of this class\n        return Object.setPrototypeOf({\n            id: { id },\n            lastUse: serverSession.lastUse,\n            txnNumber: serverSession.txnNumber,\n            isDirty: serverSession.isDirty\n        }, ServerSession.prototype);\n    }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n    constructor(client) {\n        if (client == null) {\n            throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n        }\n        this.client = client;\n        this.sessions = new utils_1.List();\n    }\n    /**\n     * Acquire a Server Session from the pool.\n     * Iterates through each session in the pool, removing any stale sessions\n     * along the way. The first non-stale session found is removed from the\n     * pool and returned. If no non-stale session is found, a new ServerSession is created.\n     */\n    acquire() {\n        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n        let session = null;\n        // Try to obtain from session pool\n        while (this.sessions.length > 0) {\n            const potentialSession = this.sessions.shift();\n            if (potentialSession != null &&\n                (!!this.client.topology?.loadBalanced ||\n                    !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n                session = potentialSession;\n                break;\n            }\n        }\n        // If nothing valid came from the pool make a new one\n        if (session == null) {\n            session = new ServerSession();\n        }\n        return session;\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n    release(session) {\n        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n        if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n            this.sessions.unshift(session);\n        }\n        if (!sessionTimeoutMinutes) {\n            return;\n        }\n        this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n        if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n            if (session.isDirty) {\n                return;\n            }\n            // otherwise, readd this session to the session pool\n            this.sessions.unshift(session);\n        }\n    }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n    if (session.hasEnded) {\n        return new error_1.MongoExpiredSessionError();\n    }\n    // May acquire serverSession here\n    const serverSession = session.serverSession;\n    if (serverSession == null) {\n        return new error_1.MongoRuntimeError('Unable to acquire server session');\n    }\n    if (options.writeConcern?.w === 0) {\n        if (session && session.explicit) {\n            // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n        }\n        return;\n    }\n    // mark the last use of this session, and apply the `lsid`\n    serverSession.lastUse = (0, utils_1.now)();\n    command.lsid = serverSession.id;\n    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n    const isRetryableWrite = !!options.willRetryWrite;\n    if (isRetryableWrite || inTxnOrTxnCommand) {\n        serverSession.txnNumber += session[kTxnNumberIncrement];\n        session[kTxnNumberIncrement] = 0;\n        // TODO(NODE-2674): Preserve int64 sent from MongoDB\n        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n    }\n    if (!inTxnOrTxnCommand) {\n        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n        }\n        if (session.supports.causalConsistency &&\n            session.operationTime &&\n            (0, utils_1.commandSupportsReadConcern)(command, options)) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n        else if (session[kSnapshotEnabled]) {\n            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };\n            if (session[kSnapshotTime] != null) {\n                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n            }\n        }\n        return;\n    }\n    // now attempt to apply transaction-specific sessions data\n    // `autocommit` must always be false to differentiate from retryable writes\n    command.autocommit = false;\n    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n        command.startTransaction = true;\n        const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n        if (readConcern) {\n            command.readConcern = readConcern;\n        }\n        if (session.supports.causalConsistency && session.operationTime) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n    }\n    return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n    if (document.$clusterTime) {\n        (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n    }\n    if (document.operationTime && session && session.supports.causalConsistency) {\n        session.advanceOperationTime(document.operationTime);\n    }\n    if (document.recoveryToken && session && session.inTransaction()) {\n        session.transaction._recoveryToken = document.recoveryToken;\n    }\n    if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n        // find and aggregate commands return atClusterTime on the cursor\n        // distinct includes it in the response body\n        const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n        if (atClusterTime) {\n            session[kSnapshotTime] = atClusterTime;\n        }\n    }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;\n"]},"metadata":{},"sourceType":"script"}