{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\n\nconst dns = require(\"dns\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\n\n\nexports.GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n});\n\nfunction externalCommand(_x, _x2) {\n  return _externalCommand.apply(this, arguments);\n}\n\nfunction _externalCommand() {\n  _externalCommand = _asyncToGenerator(function* (connection, command) {\n    return connection.commandAsync((0, utils_1.ns)('$external.$cmd'), command, undefined);\n  });\n  return _externalCommand.apply(this, arguments);\n}\n\nclass GSSAPI extends auth_provider_1.AuthProvider {\n  auth(authContext) {\n    return _asyncToGenerator(function* () {\n      const {\n        connection,\n        credentials\n      } = authContext;\n\n      if (credentials == null) {\n        throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n      }\n\n      const {\n        username\n      } = credentials;\n      const client = yield makeKerberosClient(authContext);\n      const payload = yield client.step('');\n      const saslStartResponse = yield externalCommand(connection, saslStart(payload));\n      const negotiatedPayload = yield negotiate(client, 10, saslStartResponse.payload);\n      const saslContinueResponse = yield externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));\n      const finalizePayload = yield finalize(client, username, saslContinueResponse.payload);\n      yield externalCommand(connection, {\n        saslContinue: 1,\n        conversationId: saslContinueResponse.conversationId,\n        payload: finalizePayload\n      });\n    })();\n  }\n\n}\n\nexports.GSSAPI = GSSAPI;\n\nfunction makeKerberosClient(_x3) {\n  return _makeKerberosClient.apply(this, arguments);\n}\n\nfunction _makeKerberosClient() {\n  _makeKerberosClient = _asyncToGenerator(function* (authContext) {\n    const {\n      hostAddress\n    } = authContext.options;\n    const {\n      credentials\n    } = authContext;\n\n    if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n      throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');\n    }\n\n    if ('kModuleError' in deps_1.Kerberos) {\n      throw deps_1.Kerberos['kModuleError'];\n    }\n\n    const {\n      initializeClient\n    } = deps_1.Kerberos;\n    const {\n      username,\n      password\n    } = credentials;\n    const mechanismProperties = credentials.mechanismProperties;\n    const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n    const host = yield performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n    const initOptions = {};\n\n    if (password != null) {\n      // TODO(NODE-5139): These do not match the typescript options in initializeClient\n      Object.assign(initOptions, {\n        user: username,\n        password: password\n      });\n    }\n\n    const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n    let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n\n    if ('SERVICE_REALM' in mechanismProperties) {\n      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n    }\n\n    return initializeClient(spn, initOptions);\n  });\n  return _makeKerberosClient.apply(this, arguments);\n}\n\nfunction saslStart(payload) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\n\nfunction saslContinue(payload, conversationId) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\n\nfunction negotiate(_x4, _x5, _x6) {\n  return _negotiate.apply(this, arguments);\n}\n\nfunction _negotiate() {\n  _negotiate = _asyncToGenerator(function* (client, retries, payload) {\n    try {\n      const response = yield client.step(payload);\n      return response || '';\n    } catch (error) {\n      if (retries === 0) {\n        // Retries exhausted, raise error\n        throw error;\n      } // Adjust number of retries and call step again\n\n\n      return negotiate(client, retries - 1, payload);\n    }\n  });\n  return _negotiate.apply(this, arguments);\n}\n\nfunction finalize(_x7, _x8, _x9) {\n  return _finalize.apply(this, arguments);\n}\n\nfunction _finalize() {\n  _finalize = _asyncToGenerator(function* (client, user, payload) {\n    // GSS Client Unwrap\n    const response = yield client.unwrap(payload);\n    return client.wrap(response || '', {\n      user\n    });\n  });\n  return _finalize.apply(this, arguments);\n}\n\nfunction performGSSAPICanonicalizeHostName(_x10, _x11) {\n  return _performGSSAPICanonicalizeHostName.apply(this, arguments);\n}\n\nfunction _performGSSAPICanonicalizeHostName() {\n  _performGSSAPICanonicalizeHostName = _asyncToGenerator(function* (host, mechanismProperties) {\n    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n\n    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n      return host;\n    } // If forward and reverse or true\n\n\n    if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n      // Perform the lookup of the ip address.\n      const {\n        address\n      } = yield dns.promises.lookup(host);\n\n      try {\n        // Perform a reverse ptr lookup on the ip address.\n        const results = yield dns.promises.resolvePtr(address); // If the ptr did not error but had no results, return the host.\n\n        return results.length > 0 ? results[0] : host;\n      } catch (error) {\n        // This can error as ptr records may not exist for all ips. In this case\n        // fallback to a cname lookup as dns.lookup() does not return the\n        // cname.\n        return resolveCname(host);\n      }\n    } else {\n      // The case for forward is just to resolve the cname as dns.lookup()\n      // will not return it.\n      return resolveCname(host);\n    }\n  });\n  return _performGSSAPICanonicalizeHostName.apply(this, arguments);\n}\n\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\n\nfunction resolveCname(_x12) {\n  return _resolveCname.apply(this, arguments);\n}\n\nfunction _resolveCname() {\n  _resolveCname = _asyncToGenerator(function* (host) {\n    // Attempt to resolve the host name\n    try {\n      const results = yield dns.promises.resolveCname(host); // Get the first resolved host id\n\n      return results.length > 0 ? results[0] : host;\n    } catch {\n      return host;\n    }\n  });\n  return _resolveCname.apply(this, arguments);\n}\n\nexports.resolveCname = resolveCname;","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/cmap/auth/gssapi.js"],"names":["Object","defineProperty","exports","value","resolveCname","performGSSAPICanonicalizeHostName","GSSAPI","GSSAPICanonicalizationValue","dns","require","deps_1","error_1","utils_1","auth_provider_1","freeze","on","off","none","forward","forwardAndReverse","externalCommand","connection","command","commandAsync","ns","undefined","AuthProvider","auth","authContext","credentials","MongoMissingCredentialsError","username","client","makeKerberosClient","payload","step","saslStartResponse","saslStart","negotiatedPayload","negotiate","saslContinueResponse","saslContinue","conversationId","finalizePayload","finalize","hostAddress","options","host","MongoInvalidArgumentError","Kerberos","initializeClient","password","mechanismProperties","serviceName","SERVICE_NAME","initOptions","assign","user","spnHost","SERVICE_HOST","spn","process","platform","SERVICE_REALM","mechanism","autoAuthorize","retries","response","error","unwrap","wrap","mode","CANONICALIZE_HOST_NAME","address","promises","lookup","results","resolvePtr","length"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\nconst dns = require(\"dns\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\nexports.GSSAPICanonicalizationValue = Object.freeze({\n    on: true,\n    off: false,\n    none: 'none',\n    forward: 'forward',\n    forwardAndReverse: 'forwardAndReverse'\n});\nasync function externalCommand(connection, command) {\n    return connection.commandAsync((0, utils_1.ns)('$external.$cmd'), command, undefined);\n}\nclass GSSAPI extends auth_provider_1.AuthProvider {\n    async auth(authContext) {\n        const { connection, credentials } = authContext;\n        if (credentials == null) {\n            throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n        }\n        const { username } = credentials;\n        const client = await makeKerberosClient(authContext);\n        const payload = await client.step('');\n        const saslStartResponse = await externalCommand(connection, saslStart(payload));\n        const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n        const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));\n        const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n        await externalCommand(connection, {\n            saslContinue: 1,\n            conversationId: saslContinueResponse.conversationId,\n            payload: finalizePayload\n        });\n    }\n}\nexports.GSSAPI = GSSAPI;\nasync function makeKerberosClient(authContext) {\n    const { hostAddress } = authContext.options;\n    const { credentials } = authContext;\n    if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n        throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');\n    }\n    if ('kModuleError' in deps_1.Kerberos) {\n        throw deps_1.Kerberos['kModuleError'];\n    }\n    const { initializeClient } = deps_1.Kerberos;\n    const { username, password } = credentials;\n    const mechanismProperties = credentials.mechanismProperties;\n    const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n    const initOptions = {};\n    if (password != null) {\n        // TODO(NODE-5139): These do not match the typescript options in initializeClient\n        Object.assign(initOptions, { user: username, password: password });\n    }\n    const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n    let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n    if ('SERVICE_REALM' in mechanismProperties) {\n        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n    }\n    return initializeClient(spn, initOptions);\n}\nfunction saslStart(payload) {\n    return {\n        saslStart: 1,\n        mechanism: 'GSSAPI',\n        payload,\n        autoAuthorize: 1\n    };\n}\nfunction saslContinue(payload, conversationId) {\n    return {\n        saslContinue: 1,\n        conversationId,\n        payload\n    };\n}\nasync function negotiate(client, retries, payload) {\n    try {\n        const response = await client.step(payload);\n        return response || '';\n    }\n    catch (error) {\n        if (retries === 0) {\n            // Retries exhausted, raise error\n            throw error;\n        }\n        // Adjust number of retries and call step again\n        return negotiate(client, retries - 1, payload);\n    }\n}\nasync function finalize(client, user, payload) {\n    // GSS Client Unwrap\n    const response = await client.unwrap(payload);\n    return client.wrap(response || '', { user });\n}\nasync function performGSSAPICanonicalizeHostName(host, mechanismProperties) {\n    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n        return host;\n    }\n    // If forward and reverse or true\n    if (mode === exports.GSSAPICanonicalizationValue.on ||\n        mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n        // Perform the lookup of the ip address.\n        const { address } = await dns.promises.lookup(host);\n        try {\n            // Perform a reverse ptr lookup on the ip address.\n            const results = await dns.promises.resolvePtr(address);\n            // If the ptr did not error but had no results, return the host.\n            return results.length > 0 ? results[0] : host;\n        }\n        catch (error) {\n            // This can error as ptr records may not exist for all ips. In this case\n            // fallback to a cname lookup as dns.lookup() does not return the\n            // cname.\n            return resolveCname(host);\n        }\n    }\n    else {\n        // The case for forward is just to resolve the cname as dns.lookup()\n        // will not return it.\n        return resolveCname(host);\n    }\n}\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\nasync function resolveCname(host) {\n    // Attempt to resolve the host name\n    try {\n        const results = await dns.promises.resolveCname(host);\n        // Get the first resolved host id\n        return results.length > 0 ? results[0] : host;\n    }\n    catch {\n        return host;\n    }\n}\nexports.resolveCname = resolveCname;\n"]},"metadata":{},"sourceType":"script"}