{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass DropCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name, options = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    var _this = this;\n\n    _asyncToGenerator(function* () {\n      const db = _this.db;\n      const options = _this.options;\n      const name = _this.name;\n      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configured with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = yield db.listCollections({\n          name\n        }, {\n          nameOnly: false\n        }).toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n\n          try {\n            yield dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n              throw err;\n            }\n          }\n        }\n      }\n\n      return _this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(result => callback(undefined, result), err => callback(err));\n  }\n\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      super.executeCommand(server, session, {\n        drop: this.name\n      }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n\n}\n\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\n\nclass DropDatabaseOperation extends command_1.CommandOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n\n  execute(server, session, callback) {\n    super.executeCommand(server, session, {\n      dropDatabase: 1\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n\n}\n\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/operations/drop.js"],"names":["Object","defineProperty","exports","value","DropDatabaseOperation","DropCollectionOperation","error_1","require","command_1","operation_1","CommandOperation","constructor","db","name","options","execute","server","session","callback","encryptedFieldsMap","s","client","autoEncryption","encryptedFields","databaseName","listCollectionsResult","listCollections","nameOnly","toArray","escCollection","eccCollection","ecocCollection","collectionName","dropOp","executeWithoutEncryptedFieldsCheck","err","MongoServerError","code","MONGODB_ERROR_CODES","NamespaceNotFound","then","result","undefined","Promise","resolve","reject","executeCommand","drop","ok","dropDatabase","defineAspects","Aspect","WRITE_OPERATION"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\nconst error_1 = require(\"../error\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass DropCollectionOperation extends command_1.CommandOperation {\n    constructor(db, name, options = {}) {\n        super(db, options);\n        this.db = db;\n        this.options = options;\n        this.name = name;\n    }\n    execute(server, session, callback) {\n        (async () => {\n            const db = this.db;\n            const options = this.options;\n            const name = this.name;\n            const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n            let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n            if (!encryptedFields && encryptedFieldsMap) {\n                // If the MongoClient was configured with an encryptedFieldsMap,\n                // and no encryptedFields config was available in it or explicitly\n                // passed as an argument, the spec tells us to look one up using\n                // listCollections().\n                const listCollectionsResult = await db\n                    .listCollections({ name }, { nameOnly: false })\n                    .toArray();\n                encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n            }\n            if (encryptedFields) {\n                const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n                const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n                const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n                for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n                    // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n                    const dropOp = new DropCollectionOperation(db, collectionName);\n                    try {\n                        await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n                    }\n                    catch (err) {\n                        if (!(err instanceof error_1.MongoServerError) ||\n                            err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                            throw err;\n                        }\n                    }\n                }\n            }\n            return this.executeWithoutEncryptedFieldsCheck(server, session);\n        })().then(result => callback(undefined, result), err => callback(err));\n    }\n    executeWithoutEncryptedFieldsCheck(server, session) {\n        return new Promise((resolve, reject) => {\n            super.executeCommand(server, session, { drop: this.name }, (err, result) => {\n                if (err)\n                    return reject(err);\n                resolve(!!result.ok);\n            });\n        });\n    }\n}\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\nclass DropDatabaseOperation extends command_1.CommandOperation {\n    constructor(db, options) {\n        super(db, options);\n        this.options = options;\n    }\n    execute(server, session, callback) {\n        super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {\n            if (err)\n                return callback(err);\n            if (result.ok)\n                return callback(undefined, true);\n            callback(undefined, false);\n        });\n    }\n}\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}