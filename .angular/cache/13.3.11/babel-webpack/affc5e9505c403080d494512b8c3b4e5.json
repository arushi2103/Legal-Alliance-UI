{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackWorkflow = void 0;\n\nconst bson_1 = require(\"bson\");\n\nconst error_1 = require(\"../../../error\");\n\nconst utils_1 = require(\"../../../utils\");\n\nconst providers_1 = require(\"../providers\");\n\nconst token_entry_cache_1 = require(\"./token_entry_cache\");\n/* 5 minutes in milliseconds */\n\n\nconst TIMEOUT_MS = 300000;\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\n\nclass CallbackWorkflow {\n  /**\n   * Instantiate the workflow\n   */\n  constructor() {\n    this.cache = new token_entry_cache_1.TokenEntryCache();\n  }\n  /**\n   * Get the document to add for speculative authentication. Is empty when\n   * callbacks are in play.\n   */\n\n\n  speculativeAuth() {\n    return Promise.resolve({});\n  }\n  /**\n   * Execute the workflow.\n   *\n   * Steps:\n   * - If an entry is in the cache\n   *   - If it is not expired\n   *     - Skip step one and use the entry to execute step two.\n   *   - If it is expired\n   *     - If the refresh callback exists\n   *       - remove expired entry from cache\n   *       - call the refresh callback.\n   *       - put the new entry in the cache.\n   *       - execute step two.\n   *     - If the refresh callback does not exist.\n   *       - remove expired entry from cache\n   *       - call the request callback.\n   *       - put the new entry in the cache.\n   *       - execute step two.\n   * - If no entry is in the cache.\n   *   - execute step one.\n   *   - call the refresh callback.\n   *   - put the new entry in the cache.\n   *   - execute step two.\n   */\n\n\n  execute(connection, credentials, reauthenticate = false) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n      const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n\n      const entry = _this.cache.getEntry(connection.address, credentials.username, request || null, refresh || null);\n\n      if (entry) {\n        // Check if the entry is not expired and if we are reauthenticating.\n        if (!reauthenticate && entry.isValid()) {\n          // Skip step one and execute the step two saslContinue.\n          try {\n            const result = yield finishAuth(entry.tokenResult, undefined, connection, credentials);\n            return result;\n          } catch (error) {\n            // If authentication errors when using a cached token we remove it from\n            // the cache.\n            _this.cache.deleteEntry(connection.address, credentials.username || '', request || null, refresh || null);\n\n            throw error;\n          }\n        } else {\n          // Remove the expired entry from the cache.\n          _this.cache.deleteEntry(connection.address, credentials.username || '', request || null, refresh || null); // Execute a refresh of the token and finish auth.\n\n\n          return _this.refreshAndFinish(connection, credentials, entry.serverResult, entry.tokenResult);\n        }\n      } else {\n        // No entry means to start with the step one saslStart.\n        const result = yield connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);\n        const stepOne = bson_1.BSON.deserialize(result.payload.buffer); // Call the request callback and finish auth.\n\n        return _this.requestAndFinish(connection, credentials, stepOne, result.conversationId);\n      }\n    })();\n  }\n  /**\n   * Execute the refresh callback if it exists, otherwise the request callback, then\n   * finish the authentication.\n   */\n\n\n  refreshAndFinish(connection, credentials, stepOneResult, tokenResult, conversationId) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n      const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK; // If a refresh callback exists, use it. Otherwise use the request callback.\n\n      if (refresh) {\n        const result = yield refresh(credentials.username, stepOneResult, tokenResult, TIMEOUT_MS); // Validate the result.\n\n        if (!result || !result.accessToken) {\n          throw new error_1.MongoMissingCredentialsError('REFRESH_TOKEN_CALLBACK must return a valid object with an accessToken');\n        } // Cache a new entry and continue with the saslContinue.\n\n\n        _this2.cache.addEntry(connection.address, credentials.username || '', request || null, refresh, result, stepOneResult);\n\n        return finishAuth(result, conversationId, connection, credentials);\n      } else {\n        // Fallback to using the request callback.\n        return _this2.requestAndFinish(connection, credentials, stepOneResult, conversationId);\n      }\n    })();\n  }\n  /**\n   * Execute the request callback and finish authentication.\n   */\n\n\n  requestAndFinish(connection, credentials, stepOneResult, conversationId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // Call the request callback.\n      const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n      const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK; // Always clear expired entries from the cache on each finish as cleanup.\n\n      _this3.cache.deleteExpiredEntries();\n\n      if (!request) {\n        // Request callback must be present.\n        throw new error_1.MongoInvalidArgumentError('Auth mechanism property REQUEST_TOKEN_CALLBACK is required.');\n      }\n\n      const tokenResult = yield request(credentials.username, stepOneResult, TIMEOUT_MS); // Validate the result.\n\n      if (!tokenResult || !tokenResult.accessToken) {\n        throw new error_1.MongoMissingCredentialsError('REQUEST_TOKEN_CALLBACK must return a valid object with an accessToken');\n      } // Cache a new entry and continue with the saslContinue.\n\n\n      _this3.cache.addEntry(connection.address, credentials.username || '', request, refresh || null, tokenResult, stepOneResult);\n\n      return finishAuth(tokenResult, conversationId, connection, credentials);\n    })();\n  }\n\n}\n\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\n * Cache the result of the user supplied callback and execute the\n * step two saslContinue.\n */\n\nfunction finishAuth(_x, _x2, _x3, _x4) {\n  return _finishAuth.apply(this, arguments);\n}\n/**\n * Generate the saslStart command document.\n */\n\n\nfunction _finishAuth() {\n  _finishAuth = _asyncToGenerator(function* (result, conversationId, connection, credentials) {\n    // Execute the step two saslContinue.\n    return connection.commandAsync((0, utils_1.ns)(credentials.source), continueCommandDocument(result.accessToken, conversationId), undefined);\n  });\n  return _finishAuth.apply(this, arguments);\n}\n\nfunction startCommandDocument(credentials) {\n  const payload = {};\n\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize(payload))\n  };\n}\n/**\n * Generate the saslContinue command document.\n */\n\n\nfunction continueCommandDocument(token, conversationId) {\n  if (conversationId) {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new bson_1.Binary(bson_1.BSON.serialize({\n        jwt: token\n      }))\n    };\n  } // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n\n\n  return {\n    saslStart: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize({\n      jwt: token\n    }))\n  };\n}","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js"],"names":["Object","defineProperty","exports","value","CallbackWorkflow","bson_1","require","error_1","utils_1","providers_1","token_entry_cache_1","TIMEOUT_MS","constructor","cache","TokenEntryCache","speculativeAuth","Promise","resolve","execute","connection","credentials","reauthenticate","request","mechanismProperties","REQUEST_TOKEN_CALLBACK","refresh","REFRESH_TOKEN_CALLBACK","entry","getEntry","address","username","isValid","result","finishAuth","tokenResult","undefined","error","deleteEntry","refreshAndFinish","serverResult","commandAsync","ns","source","startCommandDocument","stepOne","BSON","deserialize","payload","buffer","requestAndFinish","conversationId","stepOneResult","accessToken","MongoMissingCredentialsError","addEntry","deleteExpiredEntries","MongoInvalidArgumentError","continueCommandDocument","n","saslStart","autoAuthorize","mechanism","AuthMechanism","MONGODB_OIDC","Binary","serialize","token","saslContinue","jwt"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallbackWorkflow = void 0;\nconst bson_1 = require(\"bson\");\nconst error_1 = require(\"../../../error\");\nconst utils_1 = require(\"../../../utils\");\nconst providers_1 = require(\"../providers\");\nconst token_entry_cache_1 = require(\"./token_entry_cache\");\n/* 5 minutes in milliseconds */\nconst TIMEOUT_MS = 300000;\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nclass CallbackWorkflow {\n    /**\n     * Instantiate the workflow\n     */\n    constructor() {\n        this.cache = new token_entry_cache_1.TokenEntryCache();\n    }\n    /**\n     * Get the document to add for speculative authentication. Is empty when\n     * callbacks are in play.\n     */\n    speculativeAuth() {\n        return Promise.resolve({});\n    }\n    /**\n     * Execute the workflow.\n     *\n     * Steps:\n     * - If an entry is in the cache\n     *   - If it is not expired\n     *     - Skip step one and use the entry to execute step two.\n     *   - If it is expired\n     *     - If the refresh callback exists\n     *       - remove expired entry from cache\n     *       - call the refresh callback.\n     *       - put the new entry in the cache.\n     *       - execute step two.\n     *     - If the refresh callback does not exist.\n     *       - remove expired entry from cache\n     *       - call the request callback.\n     *       - put the new entry in the cache.\n     *       - execute step two.\n     * - If no entry is in the cache.\n     *   - execute step one.\n     *   - call the refresh callback.\n     *   - put the new entry in the cache.\n     *   - execute step two.\n     */\n    async execute(connection, credentials, reauthenticate = false) {\n        const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n        const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n        const entry = this.cache.getEntry(connection.address, credentials.username, request || null, refresh || null);\n        if (entry) {\n            // Check if the entry is not expired and if we are reauthenticating.\n            if (!reauthenticate && entry.isValid()) {\n                // Skip step one and execute the step two saslContinue.\n                try {\n                    const result = await finishAuth(entry.tokenResult, undefined, connection, credentials);\n                    return result;\n                }\n                catch (error) {\n                    // If authentication errors when using a cached token we remove it from\n                    // the cache.\n                    this.cache.deleteEntry(connection.address, credentials.username || '', request || null, refresh || null);\n                    throw error;\n                }\n            }\n            else {\n                // Remove the expired entry from the cache.\n                this.cache.deleteEntry(connection.address, credentials.username || '', request || null, refresh || null);\n                // Execute a refresh of the token and finish auth.\n                return this.refreshAndFinish(connection, credentials, entry.serverResult, entry.tokenResult);\n            }\n        }\n        else {\n            // No entry means to start with the step one saslStart.\n            const result = await connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);\n            const stepOne = bson_1.BSON.deserialize(result.payload.buffer);\n            // Call the request callback and finish auth.\n            return this.requestAndFinish(connection, credentials, stepOne, result.conversationId);\n        }\n    }\n    /**\n     * Execute the refresh callback if it exists, otherwise the request callback, then\n     * finish the authentication.\n     */\n    async refreshAndFinish(connection, credentials, stepOneResult, tokenResult, conversationId) {\n        const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n        const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n        // If a refresh callback exists, use it. Otherwise use the request callback.\n        if (refresh) {\n            const result = await refresh(credentials.username, stepOneResult, tokenResult, TIMEOUT_MS);\n            // Validate the result.\n            if (!result || !result.accessToken) {\n                throw new error_1.MongoMissingCredentialsError('REFRESH_TOKEN_CALLBACK must return a valid object with an accessToken');\n            }\n            // Cache a new entry and continue with the saslContinue.\n            this.cache.addEntry(connection.address, credentials.username || '', request || null, refresh, result, stepOneResult);\n            return finishAuth(result, conversationId, connection, credentials);\n        }\n        else {\n            // Fallback to using the request callback.\n            return this.requestAndFinish(connection, credentials, stepOneResult, conversationId);\n        }\n    }\n    /**\n     * Execute the request callback and finish authentication.\n     */\n    async requestAndFinish(connection, credentials, stepOneResult, conversationId) {\n        // Call the request callback.\n        const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n        const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n        // Always clear expired entries from the cache on each finish as cleanup.\n        this.cache.deleteExpiredEntries();\n        if (!request) {\n            // Request callback must be present.\n            throw new error_1.MongoInvalidArgumentError('Auth mechanism property REQUEST_TOKEN_CALLBACK is required.');\n        }\n        const tokenResult = await request(credentials.username, stepOneResult, TIMEOUT_MS);\n        // Validate the result.\n        if (!tokenResult || !tokenResult.accessToken) {\n            throw new error_1.MongoMissingCredentialsError('REQUEST_TOKEN_CALLBACK must return a valid object with an accessToken');\n        }\n        // Cache a new entry and continue with the saslContinue.\n        this.cache.addEntry(connection.address, credentials.username || '', request, refresh || null, tokenResult, stepOneResult);\n        return finishAuth(tokenResult, conversationId, connection, credentials);\n    }\n}\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\n * Cache the result of the user supplied callback and execute the\n * step two saslContinue.\n */\nasync function finishAuth(result, conversationId, connection, credentials) {\n    // Execute the step two saslContinue.\n    return connection.commandAsync((0, utils_1.ns)(credentials.source), continueCommandDocument(result.accessToken, conversationId), undefined);\n}\n/**\n * Generate the saslStart command document.\n */\nfunction startCommandDocument(credentials) {\n    const payload = {};\n    if (credentials.username) {\n        payload.n = credentials.username;\n    }\n    return {\n        saslStart: 1,\n        autoAuthorize: 1,\n        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n        payload: new bson_1.Binary(bson_1.BSON.serialize(payload))\n    };\n}\n/**\n * Generate the saslContinue command document.\n */\nfunction continueCommandDocument(token, conversationId) {\n    if (conversationId) {\n        return {\n            saslContinue: 1,\n            conversationId: conversationId,\n            payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))\n        };\n    }\n    // saslContinue requires a conversationId in the command to be valid so in this\n    // case the server allows \"step two\" to actually be a saslStart with the token\n    // as the jwt since the use of the cached value has no correlating conversating\n    // on the particular connection.\n    return {\n        saslStart: 1,\n        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))\n    };\n}\n"]},"metadata":{},"sourceType":"script"}