{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst server_selection_1 = require(\"../sdam/server_selection\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(client, operation, callback) {\n  return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);\n}\n\nexports.executeOperation = executeOperation;\n\nfunction executeOperationAsync(_x, _x2) {\n  return _executeOperationAsync.apply(this, arguments);\n}\n\nfunction _executeOperationAsync() {\n  _executeOperationAsync = _asyncToGenerator(function* (client, operation) {\n    if (!(operation instanceof operation_1.AbstractOperation)) {\n      // TODO(NODE-3483): Extend MongoRuntimeError\n      throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n    }\n\n    if (client.topology == null) {\n      // Auto connect on operation\n      if (client.s.hasBeenClosed) {\n        throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n      }\n\n      client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n\n      try {\n        yield client.connect();\n      } finally {\n        delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n      }\n    }\n\n    const {\n      topology\n    } = client;\n\n    if (topology == null) {\n      throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session = operation.session;\n    let owner;\n\n    if (session == null) {\n      owner = Symbol();\n      session = client.startSession({\n        owner,\n        explicit: false\n      });\n    } else if (session.hasEnded) {\n      throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n      throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n    }\n\n    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n    const inTransaction = !!session?.inTransaction();\n\n    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n      throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n    }\n\n    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n      session.unpin();\n    }\n\n    let selector;\n\n    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n      // GetMore and KillCursor operations must always select the same server, but run through\n      // server selection to potentially force monitor checks if the server is\n      // in an unknown state.\n      selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n    } else if (operation.trySecondaryWrite) {\n      // If operation should try to write to secondary use the custom server selector\n      // otherwise provide the read preference.\n      selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n    } else {\n      selector = readPreference;\n    }\n\n    const server = yield topology.selectServerAsync(selector, {\n      session\n    });\n\n    if (session == null) {\n      // No session also means it is not retryable, early exit\n      return operation.executeAsync(server, undefined);\n    }\n\n    if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      // non-retryable operation, early exit\n      try {\n        return yield operation.executeAsync(server, session);\n      } finally {\n        if (session?.owner != null && session.owner === owner) {\n          yield session.endSession().catch(() => null);\n        }\n      }\n    }\n\n    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n    const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;\n\n    if (hasWriteAspect && willRetryWrite) {\n      operation.options.willRetryWrite = true;\n      session.incrementTransactionNumber();\n    }\n\n    try {\n      return yield operation.executeAsync(server, session);\n    } catch (operationError) {\n      if (willRetry && operationError instanceof error_1.MongoError) {\n        return yield retryOperation(operation, operationError, {\n          session,\n          topology,\n          selector\n        });\n      }\n\n      throw operationError;\n    } finally {\n      if (session?.owner != null && session.owner === owner) {\n        yield session.endSession().catch(() => null);\n      }\n    }\n  });\n  return _executeOperationAsync.apply(this, arguments);\n}\n\nfunction retryOperation(_x3, _x4, _x5) {\n  return _retryOperation.apply(this, arguments);\n}\n\nfunction _retryOperation() {\n  _retryOperation = _asyncToGenerator(function* (operation, originalError, {\n    session,\n    topology,\n    selector\n  }) {\n    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n      throw new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError\n      });\n    }\n\n    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n      throw originalError;\n    }\n\n    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n      throw originalError;\n    }\n\n    if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      session.unpin({\n        force: true,\n        forceClear: true\n      });\n    } // select a new server, and attempt to retry the operation\n\n\n    const server = yield topology.selectServerAsync(selector, {\n      session\n    });\n\n    if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n      throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n    }\n\n    try {\n      return yield operation.executeAsync(server, session);\n    } catch (retryError) {\n      if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n        throw originalError;\n      }\n\n      throw retryError;\n    }\n  });\n  return _retryOperation.apply(this, arguments);\n}","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/operations/execute_operation.js"],"names":["Object","defineProperty","exports","value","executeOperation","error_1","require","read_preference_1","server_selection_1","utils_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","client","operation","callback","maybeCallback","executeOperationAsync","AbstractOperation","MongoRuntimeError","topology","s","hasBeenClosed","MongoNotConnectedError","options","Symbol","for","connect","session","owner","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","readPreference","ReadPreference","primary","inTransaction","equals","MongoTransactionError","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","hasAspect","Aspect","MUST_SELECT_SAME_SERVER","sameServerSelector","server","description","trySecondaryWrite","secondaryWritableServerSelector","commonWireVersion","selectServerAsync","executeAsync","undefined","RETRYABLE","endSession","catch","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","supportsRetryableWrites","canRetryWrite","hasReadAspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","willRetry","incrementTransactionNumber","operationError","MongoError","retryOperation","originalError","isWriteOperation","isReadOperation","code","MongoServerError","message","errmsg","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","MongoUnexpectedServerResponseError","retryError","hasErrorLabel","MongoErrorLabel","NoWritesPerformed"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executeOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n    return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);\n}\nexports.executeOperation = executeOperation;\nasync function executeOperationAsync(client, operation) {\n    if (!(operation instanceof operation_1.AbstractOperation)) {\n        // TODO(NODE-3483): Extend MongoRuntimeError\n        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n    }\n    if (client.topology == null) {\n        // Auto connect on operation\n        if (client.s.hasBeenClosed) {\n            throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n        }\n        client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n        try {\n            await client.connect();\n        }\n        finally {\n            delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n        }\n    }\n    const { topology } = client;\n    if (topology == null) {\n        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n    }\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session = operation.session;\n    let owner;\n    if (session == null) {\n        owner = Symbol();\n        session = client.startSession({ owner, explicit: false });\n    }\n    else if (session.hasEnded) {\n        throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n    }\n    else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n    }\n    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n    const inTransaction = !!session?.inTransaction();\n    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n        throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n    }\n    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n        session.unpin();\n    }\n    let selector;\n    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n        // GetMore and KillCursor operations must always select the same server, but run through\n        // server selection to potentially force monitor checks if the server is\n        // in an unknown state.\n        selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n    }\n    else if (operation.trySecondaryWrite) {\n        // If operation should try to write to secondary use the custom server selector\n        // otherwise provide the read preference.\n        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n    }\n    else {\n        selector = readPreference;\n    }\n    const server = await topology.selectServerAsync(selector, { session });\n    if (session == null) {\n        // No session also means it is not retryable, early exit\n        return operation.executeAsync(server, undefined);\n    }\n    if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n        // non-retryable operation, early exit\n        try {\n            return await operation.executeAsync(server, session);\n        }\n        finally {\n            if (session?.owner != null && session.owner === owner) {\n                await session.endSession().catch(() => null);\n            }\n        }\n    }\n    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n    const willRetryWrite = topology.s.options.retryWrites &&\n        !inTransaction &&\n        (0, utils_1.supportsRetryableWrites)(server) &&\n        operation.canRetryWrite;\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const willRetry = (hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite);\n    if (hasWriteAspect && willRetryWrite) {\n        operation.options.willRetryWrite = true;\n        session.incrementTransactionNumber();\n    }\n    try {\n        return await operation.executeAsync(server, session);\n    }\n    catch (operationError) {\n        if (willRetry && operationError instanceof error_1.MongoError) {\n            return await retryOperation(operation, operationError, {\n                session,\n                topology,\n                selector\n            });\n        }\n        throw operationError;\n    }\n    finally {\n        if (session?.owner != null && session.owner === owner) {\n            await session.endSession().catch(() => null);\n        }\n    }\n}\nasync function retryOperation(operation, originalError, { session, topology, selector }) {\n    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new error_1.MongoServerError({\n            message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n            errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n            originalError\n        });\n    }\n    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n        throw originalError;\n    }\n    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n        throw originalError;\n    }\n    if (originalError instanceof error_1.MongoNetworkError &&\n        session.isPinned &&\n        !session.inTransaction() &&\n        operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n        // If we have a cursor and the initial command fails with a network error,\n        // we can retry it on another connection. So we need to check it back in, clear the\n        // pool for the service id, and retry again.\n        session.unpin({ force: true, forceClear: true });\n    }\n    // select a new server, and attempt to retry the operation\n    const server = await topology.selectServerAsync(selector, { session });\n    if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n        throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n    }\n    try {\n        return await operation.executeAsync(server, session);\n    }\n    catch (retryError) {\n        if (retryError instanceof error_1.MongoError &&\n            retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n            throw originalError;\n        }\n        throw retryError;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}