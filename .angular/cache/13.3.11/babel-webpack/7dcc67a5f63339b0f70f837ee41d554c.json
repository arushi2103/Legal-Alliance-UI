{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = void 0;\n\nconst net = require(\"net\");\n\nconst socks_1 = require(\"socks\");\n\nconst tls = require(\"tls\");\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst auth_provider_1 = require(\"./auth/auth_provider\");\n\nconst gssapi_1 = require(\"./auth/gssapi\");\n\nconst mongocr_1 = require(\"./auth/mongocr\");\n\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\n\nconst mongodb_oidc_1 = require(\"./auth/mongodb_oidc\");\n\nconst plain_1 = require(\"./auth/plain\");\n\nconst providers_1 = require(\"./auth/providers\");\n\nconst scram_1 = require(\"./auth/scram\");\n\nconst x509_1 = require(\"./auth/x509\");\n\nconst connection_1 = require(\"./connection\");\n\nconst constants_2 = require(\"./wire_protocol/constants\");\n/** @internal */\n\n\nexports.AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\n\nfunction connect(options, callback) {\n  makeConnection({ ...options,\n    existingSocket: undefined\n  }, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = options.connectionType ?? connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    const connection = new ConnectionType(socket, options);\n    performInitialHandshake(connection, options).then(() => callback(undefined, connection), error => {\n      connection.destroy({\n        force: false\n      });\n      callback(error);\n    });\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(hello, options) {\n  const serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(_x, _x2) {\n  return _performInitialHandshake.apply(this, arguments);\n}\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\n\n\nfunction _performInitialHandshake() {\n  _performInitialHandshake = _asyncToGenerator(function* (conn, options) {\n    const credentials = options.credentials;\n\n    if (credentials) {\n      if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !exports.AUTH_PROVIDERS.get(credentials.mechanism)) {\n        throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n      }\n    }\n\n    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n    conn.authContext = authContext;\n    const handshakeDoc = yield prepareHandshakeDocument(authContext); // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n\n    const handshakeOptions = { ...options\n    };\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    const response = yield conn.commandAsync((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions);\n\n    if (!('isWritablePrimary' in response)) {\n      // Provide hello-style response document.\n      response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n    }\n\n    if (response.helloOk) {\n      conn.helloOk = true;\n    }\n\n    const supportedServerErr = checkSupportedServer(response, options);\n\n    if (supportedServerErr) {\n      throw supportedServerErr;\n    }\n\n    if (options.loadBalanced) {\n      if (!response.serviceId) {\n        throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.');\n      }\n    } // NOTE: This is metadata attached to the connection while porting away from\n    //       handshake being done in the `Server` class. Likely, it should be\n    //       relocated, or at very least restructured.\n\n\n    conn.hello = response;\n    conn.lastHelloMS = new Date().getTime() - start;\n\n    if (!response.arbiterOnly && credentials) {\n      // store the response on auth context\n      authContext.response = response;\n      const resolvedCredentials = credentials.resolveAuthMechanism(response);\n      const provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n      if (!provider) {\n        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);\n      }\n\n      try {\n        yield provider.auth(authContext);\n      } catch (error) {\n        if (error instanceof error_1.MongoError) {\n          error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n\n          if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion)) {\n            error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n          }\n        }\n\n        throw error;\n      }\n    }\n  });\n  return _performInitialHandshake.apply(this, arguments);\n}\n\nfunction prepareHandshakeDocument(_x3) {\n  return _prepareHandshakeDocument.apply(this, arguments);\n}\n\nfunction _prepareHandshakeDocument() {\n  _prepareHandshakeDocument = _asyncToGenerator(function* (authContext) {\n    const options = authContext.options;\n    const compressors = options.compressors ? options.compressors : [];\n    const {\n      serverApi\n    } = authContext.connection;\n    const handshakeDoc = {\n      [serverApi?.version ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n      helloOk: true,\n      client: options.metadata,\n      compression: compressors\n    };\n\n    if (options.loadBalanced === true) {\n      handshakeDoc.loadBalanced = true;\n    }\n\n    const credentials = authContext.credentials;\n\n    if (credentials) {\n      if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n        handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n        const provider = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n        if (!provider) {\n          // This auth mechanism is always present.\n          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);\n        }\n\n        return provider.prepare(handshakeDoc, authContext);\n      }\n\n      const provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);\n\n      if (!provider) {\n        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n      }\n\n      return provider.prepare(handshakeDoc, authContext);\n    }\n\n    return handshakeDoc;\n  });\n  return _prepareHandshakeDocument.apply(this, arguments);\n}\n\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options); // Merge in valid SSL options\n\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  const useTLS = options.tls ?? false;\n  const keepAlive = options.keepAlive ?? true;\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const keepAliveInitialDelay = ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) ?? 120000;\n  const existingSocket = options.existingSocket;\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection({ ...options,\n      connectTimeoutMS // Should always be present for Socks5\n\n    }, callback);\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(0);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nfunction makeSocks5Connection(options, callback) {\n  const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? '', // proxyHost is guaranteed to set here\n  options.proxyPort ?? 1080); // First, connect to the proxy server itself:\n\n  makeConnection({ ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }, (err, rawSocket) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const destination = parseConnectOptions(options);\n\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    } // Then, establish the Socks5 proxy connection:\n\n\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(({\n      socket\n    }) => {\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection({ ...options,\n        existingSocket: socket,\n        proxyHost: undefined\n      }, callback);\n    }, error => callback(connectionFailureError('error', error)));\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/cmap/connect.js"],"names":["Object","defineProperty","exports","value","LEGAL_TCP_SOCKET_OPTIONS","LEGAL_TLS_SOCKET_OPTIONS","prepareHandshakeDocument","connect","AUTH_PROVIDERS","net","require","socks_1","tls","bson_1","constants_1","error_1","utils_1","auth_provider_1","gssapi_1","mongocr_1","mongodb_aws_1","mongodb_oidc_1","plain_1","providers_1","scram_1","x509_1","connection_1","constants_2","Map","AuthMechanism","MONGODB_AWS","MongoDBAWS","MONGODB_CR","MongoCR","MONGODB_GSSAPI","GSSAPI","MONGODB_OIDC","MongoDBOIDC","MONGODB_PLAIN","Plain","MONGODB_SCRAM_SHA1","ScramSHA1","MONGODB_SCRAM_SHA256","ScramSHA256","MONGODB_X509","X509","options","callback","makeConnection","existingSocket","undefined","err","socket","ConnectionType","connectionType","Connection","autoEncrypter","CryptoConnection","connection","performInitialHandshake","then","error","destroy","force","checkSupportedServer","hello","serverVersionHighEnough","maxWireVersion","Int32","MIN_SUPPORTED_WIRE_VERSION","serverVersionLowEnough","minWireVersion","MAX_SUPPORTED_WIRE_VERSION","message","hostAddress","JSON","stringify","MAX_SUPPORTED_SERVER_VERSION","MongoCompatibilityError","MIN_SUPPORTED_SERVER_VERSION","conn","credentials","mechanism","MONGODB_DEFAULT","get","MongoInvalidArgumentError","authContext","AuthContext","handshakeDoc","handshakeOptions","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","response","commandAsync","ns","isWritablePrimary","LEGACY_HELLO_COMMAND","helloOk","supportedServerErr","loadBalanced","serviceId","lastHelloMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","MongoError","addErrorLabel","MongoErrorLabel","HandshakeError","needsRetryableWriteLabel","RetryableWriteError","compressors","serverApi","version","client","metadata","compression","username","saslSupportedMechs","source","prepare","parseConnectOptions","result","name","socketPath","path","host","port","MongoRuntimeError","parseSslOptions","servername","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","_callback","useTLS","keepAlive","Reflect","noDelay","rejectUnauthorized","keepAliveInitialDelay","Math","round","ret","proxyHost","makeSocks5Connection","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","process","nextTick","HostAddress","fromHostPort","proxyPort","rawSocket","destination","SocksClient","existing_socket","timeout","command","proxy","type","userId","proxyUsername","password","proxyPassword","MongoNetworkError","MongoNetworkTimeoutError"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = void 0;\nconst net = require(\"net\");\nconst socks_1 = require(\"socks\");\nconst tls = require(\"tls\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst gssapi_1 = require(\"./auth/gssapi\");\nconst mongocr_1 = require(\"./auth/mongocr\");\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\nconst mongodb_oidc_1 = require(\"./auth/mongodb_oidc\");\nconst plain_1 = require(\"./auth/plain\");\nconst providers_1 = require(\"./auth/providers\");\nconst scram_1 = require(\"./auth/scram\");\nconst x509_1 = require(\"./auth/x509\");\nconst connection_1 = require(\"./connection\");\nconst constants_2 = require(\"./wire_protocol/constants\");\n/** @internal */\nexports.AUTH_PROVIDERS = new Map([\n    [providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()],\n    [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()],\n    [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()],\n    [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC()],\n    [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()],\n    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()],\n    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()],\n    [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]\n]);\nfunction connect(options, callback) {\n    makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\n        if (err || !socket) {\n            return callback(err);\n        }\n        let ConnectionType = options.connectionType ?? connection_1.Connection;\n        if (options.autoEncrypter) {\n            ConnectionType = connection_1.CryptoConnection;\n        }\n        const connection = new ConnectionType(socket, options);\n        performInitialHandshake(connection, options).then(() => callback(undefined, connection), error => {\n            connection.destroy({ force: false });\n            callback(error);\n        });\n    });\n}\nexports.connect = connect;\nfunction checkSupportedServer(hello, options) {\n    const serverVersionHighEnough = hello &&\n        (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) &&\n        hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n    const serverVersionLowEnough = hello &&\n        (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) &&\n        hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n    if (serverVersionHighEnough) {\n        if (serverVersionLowEnough) {\n            return null;\n        }\n        const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n        return new error_1.MongoCompatibilityError(message);\n    }\n    const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n}\nasync function performInitialHandshake(conn, options) {\n    const credentials = options.credentials;\n    if (credentials) {\n        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) &&\n            !exports.AUTH_PROVIDERS.get(credentials.mechanism)) {\n            throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n        }\n    }\n    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n    conn.authContext = authContext;\n    const handshakeDoc = await prepareHandshakeDocument(authContext);\n    // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n    const handshakeOptions = { ...options };\n    if (typeof options.connectTimeoutMS === 'number') {\n        // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n        handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n    const start = new Date().getTime();\n    const response = await conn.commandAsync((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions);\n    if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n    }\n    if (response.helloOk) {\n        conn.helloOk = true;\n    }\n    const supportedServerErr = checkSupportedServer(response, options);\n    if (supportedServerErr) {\n        throw supportedServerErr;\n    }\n    if (options.loadBalanced) {\n        if (!response.serviceId) {\n            throw new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' +\n                'but the server does not support this mode.');\n        }\n    }\n    // NOTE: This is metadata attached to the connection while porting away from\n    //       handshake being done in the `Server` class. Likely, it should be\n    //       relocated, or at very least restructured.\n    conn.hello = response;\n    conn.lastHelloMS = new Date().getTime() - start;\n    if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n        if (!provider) {\n            throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);\n        }\n        try {\n            await provider.auth(authContext);\n        }\n        catch (error) {\n            if (error instanceof error_1.MongoError) {\n                error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n                if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion)) {\n                    error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n                }\n            }\n            throw error;\n        }\n    }\n}\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nasync function prepareHandshakeDocument(authContext) {\n    const options = authContext.options;\n    const compressors = options.compressors ? options.compressors : [];\n    const { serverApi } = authContext.connection;\n    const handshakeDoc = {\n        [serverApi?.version ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n        helloOk: true,\n        client: options.metadata,\n        compression: compressors\n    };\n    if (options.loadBalanced === true) {\n        handshakeDoc.loadBalanced = true;\n    }\n    const credentials = authContext.credentials;\n    if (credentials) {\n        if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n            handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n            const provider = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n            if (!provider) {\n                // This auth mechanism is always present.\n                throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);\n            }\n            return provider.prepare(handshakeDoc, authContext);\n        }\n        const provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);\n        if (!provider) {\n            throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n        }\n        return provider.prepare(handshakeDoc, authContext);\n    }\n    return handshakeDoc;\n}\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = [\n    'ALPNProtocols',\n    'ca',\n    'cert',\n    'checkServerIdentity',\n    'ciphers',\n    'crl',\n    'ecdhCurve',\n    'key',\n    'minDHSize',\n    'passphrase',\n    'pfx',\n    'rejectUnauthorized',\n    'secureContext',\n    'secureProtocol',\n    'servername',\n    'session'\n];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = [\n    'family',\n    'hints',\n    'localAddress',\n    'localPort',\n    'lookup'\n];\nfunction parseConnectOptions(options) {\n    const hostAddress = options.hostAddress;\n    if (!hostAddress)\n        throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n    const result = {};\n    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    if (typeof hostAddress.socketPath === 'string') {\n        result.path = hostAddress.socketPath;\n        return result;\n    }\n    else if (typeof hostAddress.host === 'string') {\n        result.host = hostAddress.host;\n        result.port = hostAddress.port;\n        return result;\n    }\n    else {\n        // This should never happen since we set up HostAddresses\n        // But if we don't throw here the socket could hang until timeout\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n    }\n}\nfunction parseSslOptions(options) {\n    const result = parseConnectOptions(options);\n    // Merge in valid SSL options\n    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    if (options.existingSocket) {\n        result.socket = options.existingSocket;\n    }\n    // Set default sni servername to be the same as host\n    if (result.servername == null && result.host && !net.isIP(result.host)) {\n        result.servername = result.host;\n    }\n    return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n    const useTLS = options.tls ?? false;\n    const keepAlive = options.keepAlive ?? true;\n    const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\n    const noDelay = options.noDelay ?? true;\n    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n    const rejectUnauthorized = options.rejectUnauthorized ?? true;\n    const keepAliveInitialDelay = ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS\n        ? Math.round(socketTimeoutMS / 2)\n        : options.keepAliveInitialDelay) ?? 120000;\n    const existingSocket = options.existingSocket;\n    let socket;\n    const callback = function (err, ret) {\n        if (err && socket) {\n            socket.destroy();\n        }\n        _callback(err, ret);\n    };\n    if (options.proxyHost != null) {\n        // Currently, only Socks5 is supported.\n        return makeSocks5Connection({\n            ...options,\n            connectTimeoutMS // Should always be present for Socks5\n        }, callback);\n    }\n    if (useTLS) {\n        const tlsSocket = tls.connect(parseSslOptions(options));\n        if (typeof tlsSocket.disableRenegotiation === 'function') {\n            tlsSocket.disableRenegotiation();\n        }\n        socket = tlsSocket;\n    }\n    else if (existingSocket) {\n        // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n        // so we only need to handle the non-TLS case here (where existingSocket\n        // gives us all we need out of the box).\n        socket = existingSocket;\n    }\n    else {\n        socket = net.createConnection(parseConnectOptions(options));\n    }\n    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n    socket.setTimeout(connectTimeoutMS);\n    socket.setNoDelay(noDelay);\n    const connectEvent = useTLS ? 'secureConnect' : 'connect';\n    let cancellationHandler;\n    function errorHandler(eventName) {\n        return (err) => {\n            SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n            if (cancellationHandler && options.cancellationToken) {\n                options.cancellationToken.removeListener('cancel', cancellationHandler);\n            }\n            socket.removeListener(connectEvent, connectHandler);\n            callback(connectionFailureError(eventName, err));\n        };\n    }\n    function connectHandler() {\n        SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n        if (cancellationHandler && options.cancellationToken) {\n            options.cancellationToken.removeListener('cancel', cancellationHandler);\n        }\n        if ('authorizationError' in socket) {\n            if (socket.authorizationError && rejectUnauthorized) {\n                return callback(socket.authorizationError);\n            }\n        }\n        socket.setTimeout(0);\n        callback(undefined, socket);\n    }\n    SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n    if (options.cancellationToken) {\n        cancellationHandler = errorHandler('cancel');\n        options.cancellationToken.once('cancel', cancellationHandler);\n    }\n    if (existingSocket) {\n        process.nextTick(connectHandler);\n    }\n    else {\n        socket.once(connectEvent, connectHandler);\n    }\n}\nfunction makeSocks5Connection(options, callback) {\n    const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? '', // proxyHost is guaranteed to set here\n    options.proxyPort ?? 1080);\n    // First, connect to the proxy server itself:\n    makeConnection({\n        ...options,\n        hostAddress,\n        tls: false,\n        proxyHost: undefined\n    }, (err, rawSocket) => {\n        if (err) {\n            return callback(err);\n        }\n        const destination = parseConnectOptions(options);\n        if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n            return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n        }\n        // Then, establish the Socks5 proxy connection:\n        socks_1.SocksClient.createConnection({\n            existing_socket: rawSocket,\n            timeout: options.connectTimeoutMS,\n            command: 'connect',\n            destination: {\n                host: destination.host,\n                port: destination.port\n            },\n            proxy: {\n                // host and port are ignored because we pass existing_socket\n                host: 'iLoveJavaScript',\n                port: 0,\n                type: 5,\n                userId: options.proxyUsername || undefined,\n                password: options.proxyPassword || undefined\n            }\n        }).then(({ socket }) => {\n            // Finally, now treat the resulting duplex stream as the\n            // socket over which we send and receive wire protocol messages:\n            makeConnection({\n                ...options,\n                existingSocket: socket,\n                proxyHost: undefined\n            }, callback);\n        }, error => callback(connectionFailureError('error', error)));\n    });\n}\nfunction connectionFailureError(type, err) {\n    switch (type) {\n        case 'error':\n            return new error_1.MongoNetworkError(err);\n        case 'timeout':\n            return new error_1.MongoNetworkTimeoutError('connection timed out');\n        case 'close':\n            return new error_1.MongoNetworkError('connection closed');\n        case 'cancel':\n            return new error_1.MongoNetworkError('connection establishment was cancelled');\n        default:\n            return new error_1.MongoNetworkError('unknown network error');\n    }\n}\n"]},"metadata":{},"sourceType":"script"}