{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\n\nconst util_1 = require(\"util\");\n\nconst bson_1 = require(\"./bson\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst connection_string_1 = require(\"./connection_string\");\n\nconst constants_1 = require(\"./constants\");\n\nconst db_1 = require(\"./db\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_logger_1 = require(\"./mongo_logger\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst server_selection_1 = require(\"./sdam/server_selection\");\n\nconst topology_1 = require(\"./sdam/topology\");\n\nconst sessions_1 = require(\"./sessions\");\n\nconst utils_1 = require(\"./utils\");\n/** @public */\n\n\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * // Enable command monitoring for debugging\n * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });\n *\n * client.on('commandStarted', started => console.log(started));\n * client.db().collection('pets');\n * await client.insertOne({ name: 'spot', kind: 'dog' });\n * ```\n */\n\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);\n    this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const client = this; // The internal state\n\n    this.s = {\n      url,\n      bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),\n      namespace: (0, utils_1.ns)('admin'),\n      hasBeenClosed: false,\n      sessionPool: new sessions_1.ServerSessionPool(this),\n      activeSessions: new Set(),\n\n      get options() {\n        return client[kOptions];\n      },\n\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n\n      get isMongoClient() {\n        return true;\n      }\n\n    };\n  }\n\n  get options() {\n    return Object.freeze({ ...this[kOptions]\n    });\n  }\n\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n\n\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n\n  get readConcern() {\n    return this.s.readConcern;\n  }\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get readPreference() {\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * Connect to MongoDB using a url\n   *\n   * @see docs.mongodb.org/manual/reference/connection-string/\n   */\n\n\n  connect() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.connectionLock) {\n        return _this.connectionLock;\n      }\n\n      try {\n        _this.connectionLock = _this._connect();\n        yield _this.connectionLock;\n      } finally {\n        // release\n        _this.connectionLock = undefined;\n      }\n\n      return _this;\n    })();\n  }\n  /**\n   * Create a topology to open the connection, must be locked to avoid topology leaks in concurrency scenario.\n   * Locking is enforced by the connect method.\n   *\n   * @internal\n   */\n\n\n  _connect() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.topology && _this2.topology.isConnected()) {\n        return _this2;\n      }\n\n      const options = _this2[kOptions];\n\n      if (typeof options.srvHost === 'string') {\n        const hosts = yield (0, connection_string_1.resolveSRVRecord)(options);\n\n        for (const [index, host] of hosts.entries()) {\n          options.hosts[index] = host;\n        }\n      }\n\n      const topology = new topology_1.Topology(options.hosts, options); // Events can be emitted before initialization is complete so we have to\n      // save the reference to the topology on the client ASAP if the event handlers need to access it\n\n      _this2.topology = topology;\n      topology.client = _this2;\n      topology.once(topology_1.Topology.OPEN, () => _this2.emit('open', _this2));\n\n      for (const event of constants_1.MONGO_CLIENT_EVENTS) {\n        topology.on(event, (...args) => _this2.emit(event, ...args));\n      }\n\n      const topologyConnect = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          try {\n            yield (0, util_1.promisify)(callback => topology.connect(options, callback))();\n          } catch (error) {\n            topology.close({\n              force: true\n            });\n            throw error;\n          }\n        });\n\n        return function topologyConnect() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      if (_this2.autoEncrypter) {\n        const initAutoEncrypter = (0, util_1.promisify)(callback => _this2.autoEncrypter?.init(callback));\n        yield initAutoEncrypter();\n        yield topologyConnect();\n        yield options.encrypter.connectInternalClient();\n      } else {\n        yield topologyConnect();\n      }\n\n      return _this2;\n    })();\n  }\n  /**\n   * Close the client and its underlying connections\n   *\n   * @param force - Force close, emitting no events\n   */\n\n\n  close(force = false) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // There's no way to set hasBeenClosed back to false\n      Object.defineProperty(_this3.s, 'hasBeenClosed', {\n        value: true,\n        enumerable: true,\n        configurable: false,\n        writable: false\n      });\n      const activeSessionEnds = Array.from(_this3.s.activeSessions, session => session.endSession());\n\n      _this3.s.activeSessions.clear();\n\n      yield Promise.all(activeSessionEnds);\n\n      if (_this3.topology == null) {\n        return;\n      } // If we would attempt to select a server and get nothing back we short circuit\n      // to avoid the server selection timeout.\n\n\n      const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);\n      const topologyDescription = _this3.topology.description;\n      const serverDescriptions = Array.from(topologyDescription.servers.values());\n      const servers = selector(topologyDescription, serverDescriptions);\n\n      if (servers.length !== 0) {\n        const endSessions = Array.from(_this3.s.sessionPool.sessions, ({\n          id\n        }) => id);\n\n        if (endSessions.length !== 0) {\n          yield _this3.db('admin').command({\n            endSessions\n          }, {\n            readPreference: read_preference_1.ReadPreference.primaryPreferred,\n            noResponse: true\n          }).catch(() => null); // outcome does not matter\n        }\n      } // clear out references to old topology\n\n\n      const topology = _this3.topology;\n      _this3.topology = undefined;\n      yield new Promise((resolve, reject) => {\n        topology.close({\n          force\n        }, error => {\n          if (error) return reject(error);\n          const {\n            encrypter\n          } = _this3[kOptions];\n\n          if (encrypter) {\n            return encrypter.close(_this3, force, error => {\n              if (error) return reject(error);\n              resolve();\n            });\n          }\n\n          resolve();\n        });\n      });\n    })();\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n\n\n  db(dbName, options) {\n    options = options ?? {}; // Default to db from connection string if not provided\n\n    if (!dbName) {\n      dbName = this.options.dbName;\n    } // Copy the options and add out internal override of the not shared flag\n\n\n    const finalOptions = Object.assign({}, this[kOptions], options); // Return the db object\n\n    const db = new db_1.Db(this, dbName, finalOptions); // Return the database\n\n    return db;\n  }\n  /**\n   * Connect to MongoDB using a url\n   *\n   * @remarks\n   * The programmatically provided options take precedence over the URI options.\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/connection-string/\n   */\n\n\n  static connect(url, options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const client = new _this4(url, options);\n      return client.connect();\n    })();\n  }\n  /** Starts a new session on the server */\n\n\n  startSession(options) {\n    const session = new sessions_1.ClientSession(this, this.s.sessionPool, {\n      explicit: true,\n      ...options\n    }, this[kOptions]);\n    this.s.activeSessions.add(session);\n    session.once('ended', () => {\n      this.s.activeSessions.delete(session);\n    });\n    return session;\n  }\n\n  withSession(optionsOrOperation, callback) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const options = {\n        // Always define an owner\n        owner: Symbol(),\n        // If it's an object inherit the options\n        ...(typeof optionsOrOperation === 'object' ? optionsOrOperation : {})\n      };\n      const withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;\n\n      if (withSessionCallback == null) {\n        throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n      }\n\n      const session = _this5.startSession(options);\n\n      try {\n        yield withSessionCallback(session);\n      } finally {\n        try {\n          yield session.endSession();\n        } catch {// We are not concerned with errors from endSession()\n        }\n      }\n    })();\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to provide the schema that may be defined for all the data within the current cluster\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   *\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TSchema - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n\n\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n\n}\n\nexports.MongoClient = MongoClient;","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/mongo_client.js"],"names":["Object","defineProperty","exports","value","MongoClient","ServerApiVersion","util_1","require","bson_1","change_stream_1","connection_string_1","constants_1","db_1","error_1","mongo_logger_1","mongo_types_1","read_preference_1","server_selection_1","topology_1","sessions_1","utils_1","freeze","v1","kOptions","Symbol","TypedEventEmitter","constructor","url","options","parseOptions","mongoLogger","MongoLogger","mongoLoggerOptions","client","s","bsonOptions","resolveBSONOptions","namespace","ns","hasBeenClosed","sessionPool","ServerSessionPool","activeSessions","Set","readConcern","writeConcern","readPreference","isMongoClient","serverApi","monitorCommands","autoEncrypter","connect","connectionLock","_connect","undefined","topology","isConnected","srvHost","hosts","resolveSRVRecord","index","host","entries","Topology","once","OPEN","emit","event","MONGO_CLIENT_EVENTS","on","args","topologyConnect","promisify","callback","error","close","force","initAutoEncrypter","init","encrypter","connectInternalClient","enumerable","configurable","writable","activeSessionEnds","Array","from","session","endSession","clear","Promise","all","selector","readPreferenceServerSelector","ReadPreference","primaryPreferred","topologyDescription","description","serverDescriptions","servers","values","length","endSessions","sessions","id","db","command","noResponse","catch","resolve","reject","dbName","finalOptions","assign","Db","startSession","ClientSession","explicit","add","delete","withSession","optionsOrOperation","owner","withSessionCallback","MongoInvalidArgumentError","watch","pipeline","isArray","ChangeStream","resolveOptions"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MongoClient = exports.ServerApiVersion = void 0;\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"./bson\");\nconst change_stream_1 = require(\"./change_stream\");\nconst connection_string_1 = require(\"./connection_string\");\nconst constants_1 = require(\"./constants\");\nconst db_1 = require(\"./db\");\nconst error_1 = require(\"./error\");\nconst mongo_logger_1 = require(\"./mongo_logger\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst read_preference_1 = require(\"./read_preference\");\nconst server_selection_1 = require(\"./sdam/server_selection\");\nconst topology_1 = require(\"./sdam/topology\");\nconst sessions_1 = require(\"./sessions\");\nconst utils_1 = require(\"./utils\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n    v1: '1'\n});\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * // Enable command monitoring for debugging\n * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });\n *\n * client.on('commandStarted', started => console.log(started));\n * client.db().collection('pets');\n * await client.insertOne({ name: 'spot', kind: 'dog' });\n * ```\n */\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n    constructor(url, options) {\n        super();\n        this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);\n        this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions);\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const client = this;\n        // The internal state\n        this.s = {\n            url,\n            bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),\n            namespace: (0, utils_1.ns)('admin'),\n            hasBeenClosed: false,\n            sessionPool: new sessions_1.ServerSessionPool(this),\n            activeSessions: new Set(),\n            get options() {\n                return client[kOptions];\n            },\n            get readConcern() {\n                return client[kOptions].readConcern;\n            },\n            get writeConcern() {\n                return client[kOptions].writeConcern;\n            },\n            get readPreference() {\n                return client[kOptions].readPreference;\n            },\n            get isMongoClient() {\n                return true;\n            }\n        };\n    }\n    get options() {\n        return Object.freeze({ ...this[kOptions] });\n    }\n    get serverApi() {\n        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });\n    }\n    /**\n     * Intended for APM use only\n     * @internal\n     */\n    get monitorCommands() {\n        return this[kOptions].monitorCommands;\n    }\n    set monitorCommands(value) {\n        this[kOptions].monitorCommands = value;\n    }\n    get autoEncrypter() {\n        return this[kOptions].autoEncrypter;\n    }\n    get readConcern() {\n        return this.s.readConcern;\n    }\n    get writeConcern() {\n        return this.s.writeConcern;\n    }\n    get readPreference() {\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    /**\n     * Connect to MongoDB using a url\n     *\n     * @see docs.mongodb.org/manual/reference/connection-string/\n     */\n    async connect() {\n        if (this.connectionLock) {\n            return this.connectionLock;\n        }\n        try {\n            this.connectionLock = this._connect();\n            await this.connectionLock;\n        }\n        finally {\n            // release\n            this.connectionLock = undefined;\n        }\n        return this;\n    }\n    /**\n     * Create a topology to open the connection, must be locked to avoid topology leaks in concurrency scenario.\n     * Locking is enforced by the connect method.\n     *\n     * @internal\n     */\n    async _connect() {\n        if (this.topology && this.topology.isConnected()) {\n            return this;\n        }\n        const options = this[kOptions];\n        if (typeof options.srvHost === 'string') {\n            const hosts = await (0, connection_string_1.resolveSRVRecord)(options);\n            for (const [index, host] of hosts.entries()) {\n                options.hosts[index] = host;\n            }\n        }\n        const topology = new topology_1.Topology(options.hosts, options);\n        // Events can be emitted before initialization is complete so we have to\n        // save the reference to the topology on the client ASAP if the event handlers need to access it\n        this.topology = topology;\n        topology.client = this;\n        topology.once(topology_1.Topology.OPEN, () => this.emit('open', this));\n        for (const event of constants_1.MONGO_CLIENT_EVENTS) {\n            topology.on(event, (...args) => this.emit(event, ...args));\n        }\n        const topologyConnect = async () => {\n            try {\n                await (0, util_1.promisify)(callback => topology.connect(options, callback))();\n            }\n            catch (error) {\n                topology.close({ force: true });\n                throw error;\n            }\n        };\n        if (this.autoEncrypter) {\n            const initAutoEncrypter = (0, util_1.promisify)(callback => this.autoEncrypter?.init(callback));\n            await initAutoEncrypter();\n            await topologyConnect();\n            await options.encrypter.connectInternalClient();\n        }\n        else {\n            await topologyConnect();\n        }\n        return this;\n    }\n    /**\n     * Close the client and its underlying connections\n     *\n     * @param force - Force close, emitting no events\n     */\n    async close(force = false) {\n        // There's no way to set hasBeenClosed back to false\n        Object.defineProperty(this.s, 'hasBeenClosed', {\n            value: true,\n            enumerable: true,\n            configurable: false,\n            writable: false\n        });\n        const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());\n        this.s.activeSessions.clear();\n        await Promise.all(activeSessionEnds);\n        if (this.topology == null) {\n            return;\n        }\n        // If we would attempt to select a server and get nothing back we short circuit\n        // to avoid the server selection timeout.\n        const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);\n        const topologyDescription = this.topology.description;\n        const serverDescriptions = Array.from(topologyDescription.servers.values());\n        const servers = selector(topologyDescription, serverDescriptions);\n        if (servers.length !== 0) {\n            const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);\n            if (endSessions.length !== 0) {\n                await this.db('admin')\n                    .command({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true })\n                    .catch(() => null); // outcome does not matter\n            }\n        }\n        // clear out references to old topology\n        const topology = this.topology;\n        this.topology = undefined;\n        await new Promise((resolve, reject) => {\n            topology.close({ force }, error => {\n                if (error)\n                    return reject(error);\n                const { encrypter } = this[kOptions];\n                if (encrypter) {\n                    return encrypter.close(this, force, error => {\n                        if (error)\n                            return reject(error);\n                        resolve();\n                    });\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Create a new Db instance sharing the current socket connections.\n     *\n     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n     * @param options - Optional settings for Db construction\n     */\n    db(dbName, options) {\n        options = options ?? {};\n        // Default to db from connection string if not provided\n        if (!dbName) {\n            dbName = this.options.dbName;\n        }\n        // Copy the options and add out internal override of the not shared flag\n        const finalOptions = Object.assign({}, this[kOptions], options);\n        // Return the db object\n        const db = new db_1.Db(this, dbName, finalOptions);\n        // Return the database\n        return db;\n    }\n    /**\n     * Connect to MongoDB using a url\n     *\n     * @remarks\n     * The programmatically provided options take precedence over the URI options.\n     *\n     * @see https://www.mongodb.com/docs/manual/reference/connection-string/\n     */\n    static async connect(url, options) {\n        const client = new this(url, options);\n        return client.connect();\n    }\n    /** Starts a new session on the server */\n    startSession(options) {\n        const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this[kOptions]);\n        this.s.activeSessions.add(session);\n        session.once('ended', () => {\n            this.s.activeSessions.delete(session);\n        });\n        return session;\n    }\n    async withSession(optionsOrOperation, callback) {\n        const options = {\n            // Always define an owner\n            owner: Symbol(),\n            // If it's an object inherit the options\n            ...(typeof optionsOrOperation === 'object' ? optionsOrOperation : {})\n        };\n        const withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;\n        if (withSessionCallback == null) {\n            throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n        }\n        const session = this.startSession(options);\n        try {\n            await withSessionCallback(session);\n        }\n        finally {\n            try {\n                await session.endSession();\n            }\n            catch {\n                // We are not concerned with errors from endSession()\n            }\n        }\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this cluster. Will ignore all\n     * changes to system collections, as well as the local, admin, and config databases.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct use cases:\n     * - The first is to provide the schema that may be defined for all the data within the current cluster\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     *\n     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TSchema - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n}\nexports.MongoClient = MongoClient;\n"]},"metadata":{},"sourceType":"script"}