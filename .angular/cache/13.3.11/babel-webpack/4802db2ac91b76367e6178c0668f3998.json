{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst download_1 = require(\"./download\");\n\nconst upload_1 = require(\"./upload\");\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\n\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = { ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, options);\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n\n\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, { ...options,\n      id\n    });\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n\n\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, options);\n  }\n  /**\n   * Deletes a file with the given id\n   *\n   * @param id - The id of the file doc\n   */\n\n\n  delete(id) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        deletedCount\n      } = yield _this.s._filesCollection.deleteOne({\n        _id: id\n      }); // Delete orphaned chunks before returning FileNotFound\n\n      yield _this.s._chunksCollection.deleteMany({\n        files_id: id\n      });\n\n      if (deletedCount === 0) {\n        // TODO(NODE-3483): Replace with more appropriate error\n        // Consider creating new error MongoGridFSFileNotFoundError\n        throw new error_1.MongoRuntimeError(`File not found for id ${id}`);\n      }\n    })();\n  }\n  /** Convenience wrapper around find on the files collection */\n\n\n  find(filter = {}, options = {}) {\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n\n\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, { ...options,\n      sort,\n      skip\n    });\n  }\n  /**\n   * Renames the file with the given _id to the given string\n   *\n   * @param id - the id of the file to rename\n   * @param filename - new name for the file\n   */\n\n\n  rename(id, filename) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const filter = {\n        _id: id\n      };\n      const update = {\n        $set: {\n          filename\n        }\n      };\n      const {\n        matchedCount\n      } = yield _this2.s._filesCollection.updateOne(filter, update);\n\n      if (matchedCount === 0) {\n        throw new error_1.MongoRuntimeError(`File with id ${id} not found`);\n      }\n    })();\n  }\n  /** Removes this bucket's files collection, followed by its chunks collection. */\n\n\n  drop() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.s._filesCollection.drop();\n      yield _this3.s._chunksCollection.drop();\n    })();\n  }\n\n}\n\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\n\nGridFSBucket.INDEX = 'index';","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/gridfs/index.js"],"names":["Object","defineProperty","exports","value","GridFSBucket","error_1","require","mongo_types_1","write_concern_1","download_1","upload_1","DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","TypedEventEmitter","constructor","db","options","setMaxListeners","privateOptions","writeConcern","WriteConcern","fromOptions","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","openUploadStream","filename","GridFSBucketWriteStream","openUploadStreamWithId","id","openDownloadStream","GridFSBucketReadStream","readPreference","_id","delete","deletedCount","deleteOne","deleteMany","files_id","MongoRuntimeError","find","filter","openDownloadStreamByName","sort","uploadDate","skip","undefined","revision","rename","update","$set","matchedCount","updateOne","drop","INDEX"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridFSBucket = void 0;\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst write_concern_1 = require(\"../write_concern\");\nconst download_1 = require(\"./download\");\nconst upload_1 = require(\"./upload\");\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n    bucketName: 'fs',\n    chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n    constructor(db, options) {\n        super();\n        this.setMaxListeners(0);\n        const privateOptions = {\n            ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n            ...options,\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n        };\n        this.s = {\n            db,\n            options: privateOptions,\n            _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n            _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n            checkedIndexes: false,\n            calledOpenUploadStream: false\n        };\n    }\n    /**\n     * Returns a writable stream (GridFSBucketWriteStream) for writing\n     * buffers to GridFS. The stream's 'id' property contains the resulting\n     * file's id.\n     *\n     * @param filename - The value of the 'filename' key in the files doc\n     * @param options - Optional settings.\n     */\n    openUploadStream(filename, options) {\n        return new upload_1.GridFSBucketWriteStream(this, filename, options);\n    }\n    /**\n     * Returns a writable stream (GridFSBucketWriteStream) for writing\n     * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n     * file's id.\n     */\n    openUploadStreamWithId(id, filename, options) {\n        return new upload_1.GridFSBucketWriteStream(this, filename, { ...options, id });\n    }\n    /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n    openDownloadStream(id, options) {\n        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, options);\n    }\n    /**\n     * Deletes a file with the given id\n     *\n     * @param id - The id of the file doc\n     */\n    async delete(id) {\n        const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id });\n        // Delete orphaned chunks before returning FileNotFound\n        await this.s._chunksCollection.deleteMany({ files_id: id });\n        if (deletedCount === 0) {\n            // TODO(NODE-3483): Replace with more appropriate error\n            // Consider creating new error MongoGridFSFileNotFoundError\n            throw new error_1.MongoRuntimeError(`File not found for id ${id}`);\n        }\n    }\n    /** Convenience wrapper around find on the files collection */\n    find(filter = {}, options = {}) {\n        return this.s._filesCollection.find(filter, options);\n    }\n    /**\n     * Returns a readable stream (GridFSBucketReadStream) for streaming the\n     * file with the given name from GridFS. If there are multiple files with\n     * the same name, this will stream the most recent file with the given name\n     * (as determined by the `uploadDate` field). You can set the `revision`\n     * option to change this behavior.\n     */\n    openDownloadStreamByName(filename, options) {\n        let sort = { uploadDate: -1 };\n        let skip = undefined;\n        if (options && options.revision != null) {\n            if (options.revision >= 0) {\n                sort = { uploadDate: 1 };\n                skip = options.revision;\n            }\n            else {\n                skip = -options.revision - 1;\n            }\n        }\n        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { ...options, sort, skip });\n    }\n    /**\n     * Renames the file with the given _id to the given string\n     *\n     * @param id - the id of the file to rename\n     * @param filename - new name for the file\n     */\n    async rename(id, filename) {\n        const filter = { _id: id };\n        const update = { $set: { filename } };\n        const { matchedCount } = await this.s._filesCollection.updateOne(filter, update);\n        if (matchedCount === 0) {\n            throw new error_1.MongoRuntimeError(`File with id ${id} not found`);\n        }\n    }\n    /** Removes this bucket's files collection, followed by its chunks collection. */\n    async drop() {\n        await this.s._filesCollection.drop();\n        await this.s._chunksCollection.drop();\n    }\n}\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\nGridFSBucket.INDEX = 'index';\n"]},"metadata":{},"sourceType":"script"}