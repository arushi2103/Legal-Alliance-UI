{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncIterator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\wrapAsyncGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst util_1 = require(\"util\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst get_more_1 = require(\"../operations/get_more\");\n\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n/** @internal */\n\n\nconst kId = Symbol('id');\n/** @internal */\n\nconst kDocuments = Symbol('documents');\n/** @internal */\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kNamespace = Symbol('namespace');\n/** @internal */\n\nconst kClient = Symbol('client');\n/** @internal */\n\nconst kSession = Symbol('session');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/** @internal */\n\nconst kTransform = Symbol('transform');\n/** @internal */\n\nconst kInitialized = Symbol('initialized');\n/** @internal */\n\nconst kClosed = Symbol('closed');\n/** @internal */\n\nconst kKilled = Symbol('killed');\n/** @internal */\n\nconst kInit = Symbol('kInit');\n/** @public */\n\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\n\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace, options = {}) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kId] = null;\n    this[kDocuments] = new utils_1.List();\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n\n  get id() {\n    return this[kId] ?? undefined;\n  }\n  /** @internal */\n\n\n  get client() {\n    return this[kClient];\n  }\n  /** @internal */\n\n\n  get server() {\n    return this[kServer];\n  }\n\n  get namespace() {\n    return this[kNamespace];\n  }\n\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n\n\n  get session() {\n    return this[kSession];\n  }\n\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n\n\n  get cursorOptions() {\n    return this[kOptions];\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get killed() {\n    return this[kKilled];\n  }\n\n  get loadBalanced() {\n    return !!this[kClient].topology?.loadBalanced;\n  }\n  /** Returns current buffered documents length */\n\n\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n\n\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this[kDocuments].shift();\n\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  [Symbol.asyncIterator]() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      if (_this.closed) {\n        return;\n      }\n\n      try {\n        while (true) {\n          const document = yield _awaitAsyncGenerator(_this.next()); // Intentional strict null check, because users can map cursors to falsey values.\n          // We allow mapping to all values except for null.\n          // eslint-disable-next-line no-restricted-syntax\n\n          if (document === null) {\n            if (!_this.closed) {\n              const message = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n              yield _awaitAsyncGenerator(cleanupCursorAsync(_this, {\n                needsToEmitClosed: true\n              }).catch(() => null));\n              throw new error_1.MongoAPIError(message);\n            }\n\n            break;\n          }\n\n          yield document;\n\n          if (_this[kId] === bson_1.Long.ZERO) {\n            // Cursor exhausted\n            break;\n          }\n        }\n      } finally {\n        // Only close the cursor if it has not already been closed. This finally clause handles\n        // the case when a user would break out of a for await of loop early.\n        if (!_this.closed) {\n          yield _awaitAsyncGenerator(_this.close().catch(() => null));\n        }\n      }\n    })();\n  }\n\n  stream(options) {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n\n      }));\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  hasNext() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2[kId] === bson_1.Long.ZERO) {\n        return false;\n      }\n\n      if (_this2[kDocuments].length !== 0) {\n        return true;\n      }\n\n      const doc = yield nextAsync(_this2, true);\n\n      if (doc) {\n        _this2[kDocuments].unshift(doc);\n\n        return true;\n      }\n\n      return false;\n    })();\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n\n\n  next() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3[kId] === bson_1.Long.ZERO) {\n        throw new error_1.MongoCursorExhaustedError();\n      }\n\n      return nextAsync(_this3, true);\n    })();\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n\n\n  tryNext() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4[kId] === bson_1.Long.ZERO) {\n        throw new error_1.MongoCursorExhaustedError();\n      }\n\n      return nextAsync(_this4, false);\n    })();\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   */\n\n\n  forEach(iterator) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof iterator !== 'function') {\n        throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n      }\n\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this5), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const document = _step.value;\n          const result = iterator(document);\n\n          if (result === false) {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n\n  close() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const needsToEmitClosed = !_this6[kClosed];\n      _this6[kClosed] = true;\n      yield cleanupCursorAsync(_this6, {\n        needsToEmitClosed\n      });\n    })();\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n\n\n  toArray() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const array = [];\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(_this7), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n          const document = _step2.value;\n          array.push(document);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return array;\n    })();\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n\n\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n\n\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n\n\n  maxTimeMS(value) {\n    assertUninitialized(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n\n\n  batchSize(value) {\n    assertUninitialized(this);\n\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n\n\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = null;\n    this[kDocuments].clear();\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n\n        this[kSession] = this.client.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n\n\n  _getMore(batchSize, callback) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], { ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n    (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n\n\n  [kInit](callback) {\n    this._initialize(this[kSession], (error, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n\n        if (response.cursor) {\n          // TODO(NODE-2674): Preserve int64 sent from MongoDB\n          this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;\n\n          if (response.cursor.ns) {\n            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n          }\n\n          this[kDocuments].pushMany(response.cursor.firstBatch);\n        } // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n\n\n        if (this[kId] == null) {\n          this[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n\n          this[kDocuments].push(state.response);\n        }\n      } // the cursor is now initialized, even if an error occurred or it is dead\n\n\n      this[kInitialized] = true;\n\n      if (error) {\n        return cleanupCursor(this, {\n          error\n        }, () => callback(error, undefined));\n      }\n\n      if (cursorIsDead(this)) {\n        return cleanupCursor(this, undefined, () => callback());\n      }\n\n      callback();\n    });\n  }\n\n}\n\nexports.AbstractCursor = AbstractCursor;\n/** @event */\n\nAbstractCursor.CLOSE = 'close';\n\nfunction nextDocument(cursor) {\n  const doc = cursor[kDocuments].shift();\n\n  if (doc && cursor[kTransform]) {\n    return cursor[kTransform](doc);\n  }\n\n  return doc;\n}\n\nconst nextAsync = (0, util_1.promisify)(next);\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\n\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments].length !== 0) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit](err => {\n      if (err) return callback(err);\n      return next(cursor, blocking, callback);\n    });\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  } // otherwise need to call getMore\n\n\n  const batchSize = cursor[kOptions].batchSize || 1000;\n\n  cursor._getMore(batchSize, (error, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments].pushMany(response.cursor.nextBatch);\n      cursor[kId] = cursorId;\n    }\n\n    if (error || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error\n      }, () => callback(error, nextDocument(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nexports.next = next;\n\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nconst cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);\n\nfunction cleanupCursor(cursor, options, callback) {\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options?.error;\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        session.endSession({\n          error\n        }).finally(() => {\n          callback();\n        });\n        return;\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        session.endSession({\n          error\n        }).finally(() => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n        return;\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n\n  if (session.hasEnded) {\n    return completeCleanup();\n  }\n\n  (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n    session\n  })).catch(() => null).finally(completeCleanup);\n}\n/** @internal */\n\n\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\n\nexports.assertUninitialized = assertUninitialized;\n\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n\n      this._readNext();\n    }\n  }\n\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n\n  _readNext() {\n    next(this._cursor, true, (err, result) => {\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().catch(() => null);\n\n          return this.push(null);\n        } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n\n\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        } // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n\n\n        return this.destroy(err);\n      }\n\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n\n        this._readInProgress = false;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/cursor/abstract_cursor.js"],"names":["Object","defineProperty","exports","value","assertUninitialized","next","AbstractCursor","CURSOR_FLAGS","stream_1","require","util_1","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","sessions_1","utils_1","kId","Symbol","kDocuments","kServer","kNamespace","kClient","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","kInit","TypedEventEmitter","constructor","client","namespace","options","s","isMongoClient","MongoRuntimeError","List","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","readConcern","ReadConcern","fromOptions","batchSize","comment","undefined","maxTimeMS","maxAwaitTimeMS","session","ClientSession","startSession","owner","explicit","id","server","clientSession","cursorOptions","closed","killed","loadBalanced","topology","bufferedCount","length","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","asyncIterator","message","cleanupCursorAsync","needsToEmitClosed","catch","MongoAPIError","Long","ZERO","close","stream","transform","readable","ReadableCursorStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","hasNext","doc","nextAsync","unshift","MongoCursorExhaustedError","tryNext","forEach","iterator","MongoInvalidArgumentError","result","toArray","array","addCursorFlag","flag","includes","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","MongoTailableCursorError","rewind","clear","hasEnded","endSession","_getMore","getMoreOperation","GetMoreOperation","executeOperation","_initialize","error","state","response","cursor","fromNumber","fromBigInt","ns","pushMany","firstBatch","cleanupCursor","cursorIsDead","CLOSE","nextDocument","promisify","blocking","cursorId","nextBatch","isZero","cursorNs","MongoNetworkError","completeCleanup","emit","finally","inTransaction","maybeClearPinnedConnection","KillCursorsOperation","MongoCursorInUseError","Readable","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","then","closeError","match","destroy","destroyed"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n/** @public */\nexports.CURSOR_FLAGS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'exhaust',\n    'partial'\n];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n    /** @internal */\n    constructor(client, namespace, options = {}) {\n        super();\n        if (!client.s.isMongoClient) {\n            throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n        }\n        this[kClient] = client;\n        this[kNamespace] = namespace;\n        this[kId] = null;\n        this[kDocuments] = new utils_1.List();\n        this[kInitialized] = false;\n        this[kClosed] = false;\n        this[kKilled] = false;\n        this[kOptions] = {\n            readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference\n                ? options.readPreference\n                : read_preference_1.ReadPreference.primary,\n            ...(0, bson_1.pluckBSONSerializeOptions)(options)\n        };\n        const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n        if (readConcern) {\n            this[kOptions].readConcern = readConcern;\n        }\n        if (typeof options.batchSize === 'number') {\n            this[kOptions].batchSize = options.batchSize;\n        }\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (options.comment !== undefined) {\n            this[kOptions].comment = options.comment;\n        }\n        if (typeof options.maxTimeMS === 'number') {\n            this[kOptions].maxTimeMS = options.maxTimeMS;\n        }\n        if (typeof options.maxAwaitTimeMS === 'number') {\n            this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n        }\n        if (options.session instanceof sessions_1.ClientSession) {\n            this[kSession] = options.session;\n        }\n        else {\n            this[kSession] = this[kClient].startSession({ owner: this, explicit: false });\n        }\n    }\n    get id() {\n        return this[kId] ?? undefined;\n    }\n    /** @internal */\n    get client() {\n        return this[kClient];\n    }\n    /** @internal */\n    get server() {\n        return this[kServer];\n    }\n    get namespace() {\n        return this[kNamespace];\n    }\n    get readPreference() {\n        return this[kOptions].readPreference;\n    }\n    get readConcern() {\n        return this[kOptions].readConcern;\n    }\n    /** @internal */\n    get session() {\n        return this[kSession];\n    }\n    set session(clientSession) {\n        this[kSession] = clientSession;\n    }\n    /** @internal */\n    get cursorOptions() {\n        return this[kOptions];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get killed() {\n        return this[kKilled];\n    }\n    get loadBalanced() {\n        return !!this[kClient].topology?.loadBalanced;\n    }\n    /** Returns current buffered documents length */\n    bufferedCount() {\n        return this[kDocuments].length;\n    }\n    /** Returns current buffered documents */\n    readBufferedDocuments(number) {\n        const bufferedDocs = [];\n        const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);\n        for (let count = 0; count < documentsToRead; count++) {\n            const document = this[kDocuments].shift();\n            if (document != null) {\n                bufferedDocs.push(document);\n            }\n        }\n        return bufferedDocs;\n    }\n    async *[Symbol.asyncIterator]() {\n        if (this.closed) {\n            return;\n        }\n        try {\n            while (true) {\n                const document = await this.next();\n                // Intentional strict null check, because users can map cursors to falsey values.\n                // We allow mapping to all values except for null.\n                // eslint-disable-next-line no-restricted-syntax\n                if (document === null) {\n                    if (!this.closed) {\n                        const message = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n                        await cleanupCursorAsync(this, { needsToEmitClosed: true }).catch(() => null);\n                        throw new error_1.MongoAPIError(message);\n                    }\n                    break;\n                }\n                yield document;\n                if (this[kId] === bson_1.Long.ZERO) {\n                    // Cursor exhausted\n                    break;\n                }\n            }\n        }\n        finally {\n            // Only close the cursor if it has not already been closed. This finally clause handles\n            // the case when a user would break out of a for await of loop early.\n            if (!this.closed) {\n                await this.close().catch(() => null);\n            }\n        }\n    }\n    stream(options) {\n        if (options?.transform) {\n            const transform = options.transform;\n            const readable = new ReadableCursorStream(this);\n            return readable.pipe(new stream_1.Transform({\n                objectMode: true,\n                highWaterMark: 1,\n                transform(chunk, _, callback) {\n                    try {\n                        const transformed = transform(chunk);\n                        callback(undefined, transformed);\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                }\n            }));\n        }\n        return new ReadableCursorStream(this);\n    }\n    async hasNext() {\n        if (this[kId] === bson_1.Long.ZERO) {\n            return false;\n        }\n        if (this[kDocuments].length !== 0) {\n            return true;\n        }\n        const doc = await nextAsync(this, true);\n        if (doc) {\n            this[kDocuments].unshift(doc);\n            return true;\n        }\n        return false;\n    }\n    /** Get the next available document from the cursor, returns null if no more documents are available. */\n    async next() {\n        if (this[kId] === bson_1.Long.ZERO) {\n            throw new error_1.MongoCursorExhaustedError();\n        }\n        return nextAsync(this, true);\n    }\n    /**\n     * Try to get the next available document from the cursor or `null` if an empty batch is returned\n     */\n    async tryNext() {\n        if (this[kId] === bson_1.Long.ZERO) {\n            throw new error_1.MongoCursorExhaustedError();\n        }\n        return nextAsync(this, false);\n    }\n    /**\n     * Iterates over all the documents for this cursor using the iterator, callback pattern.\n     *\n     * If the iterator returns `false`, iteration will stop.\n     *\n     * @param iterator - The iteration callback.\n     */\n    async forEach(iterator) {\n        if (typeof iterator !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n        }\n        for await (const document of this) {\n            const result = iterator(document);\n            if (result === false) {\n                break;\n            }\n        }\n    }\n    async close() {\n        const needsToEmitClosed = !this[kClosed];\n        this[kClosed] = true;\n        await cleanupCursorAsync(this, { needsToEmitClosed });\n    }\n    /**\n     * Returns an array of documents. The caller is responsible for making sure that there\n     * is enough memory to store the results. Note that the array only contains partial\n     * results when this cursor had been previously accessed. In that case,\n     * cursor.rewind() can be used to reset the cursor.\n     */\n    async toArray() {\n        const array = [];\n        for await (const document of this) {\n            array.push(document);\n        }\n        return array;\n    }\n    /**\n     * Add a cursor flag to the cursor\n     *\n     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n     * @param value - The flag boolean value.\n     */\n    addCursorFlag(flag, value) {\n        assertUninitialized(this);\n        if (!exports.CURSOR_FLAGS.includes(flag)) {\n            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n        }\n        if (typeof value !== 'boolean') {\n            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n        }\n        this[kOptions][flag] = value;\n        return this;\n    }\n    /**\n     * Map all documents using the provided function\n     * If there is a transform set on the cursor, that will be called first and the result passed to\n     * this function's transform.\n     *\n     * @remarks\n     *\n     * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n     * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n     * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n     *\n     * ```typescript\n     * const cursor = collection.find({});\n     * cursor.map(() => null);\n     *\n     * const documents = await cursor.toArray();\n     * // documents is always [], regardless of how many documents are in the collection.\n     * ```\n     *\n     * Other falsey values are allowed:\n     *\n     * ```typescript\n     * const cursor = collection.find({});\n     * cursor.map(() => '');\n     *\n     * const documents = await cursor.toArray();\n     * // documents is now an array of empty strings\n     * ```\n     *\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling map,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: FindCursor<Document> = coll.find();\n     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n     * ```\n     * @param transform - The mapping transformation method.\n     */\n    map(transform) {\n        assertUninitialized(this);\n        const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n        if (oldTransform) {\n            this[kTransform] = doc => {\n                return transform(oldTransform(doc));\n            };\n        }\n        else {\n            this[kTransform] = transform;\n        }\n        return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n    withReadPreference(readPreference) {\n        assertUninitialized(this);\n        if (readPreference instanceof read_preference_1.ReadPreference) {\n            this[kOptions].readPreference = readPreference;\n        }\n        else if (typeof readPreference === 'string') {\n            this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n        }\n        else {\n            throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n        }\n        return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n    withReadConcern(readConcern) {\n        assertUninitialized(this);\n        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });\n        if (resolvedReadConcern) {\n            this[kOptions].readConcern = resolvedReadConcern;\n        }\n        return this;\n    }\n    /**\n     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n     *\n     * @param value - Number of milliseconds to wait before aborting the query.\n     */\n    maxTimeMS(value) {\n        assertUninitialized(this);\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n        }\n        this[kOptions].maxTimeMS = value;\n        return this;\n    }\n    /**\n     * Set the batch size for the cursor.\n     *\n     * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n     */\n    batchSize(value) {\n        assertUninitialized(this);\n        if (this[kOptions].tailable) {\n            throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n        }\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n        }\n        this[kOptions].batchSize = value;\n        return this;\n    }\n    /**\n     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n     * if the resultant data has already been retrieved by this cursor.\n     */\n    rewind() {\n        if (!this[kInitialized]) {\n            return;\n        }\n        this[kId] = null;\n        this[kDocuments].clear();\n        this[kClosed] = false;\n        this[kKilled] = false;\n        this[kInitialized] = false;\n        const session = this[kSession];\n        if (session) {\n            // We only want to end this session if we created it, and it hasn't ended yet\n            if (session.explicit === false) {\n                if (!session.hasEnded) {\n                    session.endSession().catch(() => null);\n                }\n                this[kSession] = this.client.startSession({ owner: this, explicit: false });\n            }\n        }\n    }\n    /** @internal */\n    _getMore(batchSize, callback) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], {\n            ...this[kOptions],\n            session: this[kSession],\n            batchSize\n        });\n        (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n    }\n    /**\n     * @internal\n     *\n     * This function is exposed for the unified test runner's createChangeStream\n     * operation.  We cannot refactor to use the abstract _initialize method without\n     * a significant refactor.\n     */\n    [kInit](callback) {\n        this._initialize(this[kSession], (error, state) => {\n            if (state) {\n                const response = state.response;\n                this[kServer] = state.server;\n                if (response.cursor) {\n                    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n                    this[kId] =\n                        typeof response.cursor.id === 'number'\n                            ? bson_1.Long.fromNumber(response.cursor.id)\n                            : typeof response.cursor.id === 'bigint'\n                                ? bson_1.Long.fromBigInt(response.cursor.id)\n                                : response.cursor.id;\n                    if (response.cursor.ns) {\n                        this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n                    }\n                    this[kDocuments].pushMany(response.cursor.firstBatch);\n                }\n                // When server responses return without a cursor document, we close this cursor\n                // and return the raw server response. This is often the case for explain commands\n                // for example\n                if (this[kId] == null) {\n                    this[kId] = bson_1.Long.ZERO;\n                    // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n                    this[kDocuments].push(state.response);\n                }\n            }\n            // the cursor is now initialized, even if an error occurred or it is dead\n            this[kInitialized] = true;\n            if (error) {\n                return cleanupCursor(this, { error }, () => callback(error, undefined));\n            }\n            if (cursorIsDead(this)) {\n                return cleanupCursor(this, undefined, () => callback());\n            }\n            callback();\n        });\n    }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nfunction nextDocument(cursor) {\n    const doc = cursor[kDocuments].shift();\n    if (doc && cursor[kTransform]) {\n        return cursor[kTransform](doc);\n    }\n    return doc;\n}\nconst nextAsync = (0, util_1.promisify)(next);\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\nfunction next(cursor, blocking, callback) {\n    const cursorId = cursor[kId];\n    if (cursor.closed) {\n        return callback(undefined, null);\n    }\n    if (cursor[kDocuments].length !== 0) {\n        callback(undefined, nextDocument(cursor));\n        return;\n    }\n    if (cursorId == null) {\n        // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n        cursor[kInit](err => {\n            if (err)\n                return callback(err);\n            return next(cursor, blocking, callback);\n        });\n        return;\n    }\n    if (cursorIsDead(cursor)) {\n        return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n    }\n    // otherwise need to call getMore\n    const batchSize = cursor[kOptions].batchSize || 1000;\n    cursor._getMore(batchSize, (error, response) => {\n        if (response) {\n            const cursorId = typeof response.cursor.id === 'number'\n                ? bson_1.Long.fromNumber(response.cursor.id)\n                : typeof response.cursor.id === 'bigint'\n                    ? bson_1.Long.fromBigInt(response.cursor.id)\n                    : response.cursor.id;\n            cursor[kDocuments].pushMany(response.cursor.nextBatch);\n            cursor[kId] = cursorId;\n        }\n        if (error || cursorIsDead(cursor)) {\n            return cleanupCursor(cursor, { error }, () => callback(error, nextDocument(cursor)));\n        }\n        if (cursor[kDocuments].length === 0 && blocking === false) {\n            return callback(undefined, null);\n        }\n        next(cursor, blocking, callback);\n    });\n}\nexports.next = next;\nfunction cursorIsDead(cursor) {\n    const cursorId = cursor[kId];\n    return !!cursorId && cursorId.isZero();\n}\nconst cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);\nfunction cleanupCursor(cursor, options, callback) {\n    const cursorId = cursor[kId];\n    const cursorNs = cursor[kNamespace];\n    const server = cursor[kServer];\n    const session = cursor[kSession];\n    const error = options?.error;\n    const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\n    if (error) {\n        if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n            return completeCleanup();\n        }\n    }\n    if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n        if (needsToEmitClosed) {\n            cursor[kClosed] = true;\n            cursor[kId] = bson_1.Long.ZERO;\n            cursor.emit(AbstractCursor.CLOSE);\n        }\n        if (session) {\n            if (session.owner === cursor) {\n                session.endSession({ error }).finally(() => {\n                    callback();\n                });\n                return;\n            }\n            if (!session.inTransaction()) {\n                (0, sessions_1.maybeClearPinnedConnection)(session, { error });\n            }\n        }\n        return callback();\n    }\n    function completeCleanup() {\n        if (session) {\n            if (session.owner === cursor) {\n                session.endSession({ error }).finally(() => {\n                    cursor.emit(AbstractCursor.CLOSE);\n                    callback();\n                });\n                return;\n            }\n            if (!session.inTransaction()) {\n                (0, sessions_1.maybeClearPinnedConnection)(session, { error });\n            }\n        }\n        cursor.emit(AbstractCursor.CLOSE);\n        return callback();\n    }\n    cursor[kKilled] = true;\n    if (session.hasEnded) {\n        return completeCleanup();\n    }\n    (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, { session }))\n        .catch(() => null)\n        .finally(completeCleanup);\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n    if (cursor[kInitialized]) {\n        throw new error_1.MongoCursorInUseError();\n    }\n}\nexports.assertUninitialized = assertUninitialized;\nclass ReadableCursorStream extends stream_1.Readable {\n    constructor(cursor) {\n        super({\n            objectMode: true,\n            autoDestroy: false,\n            highWaterMark: 1\n        });\n        this._readInProgress = false;\n        this._cursor = cursor;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _read(size) {\n        if (!this._readInProgress) {\n            this._readInProgress = true;\n            this._readNext();\n        }\n    }\n    _destroy(error, callback) {\n        this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n    }\n    _readNext() {\n        next(this._cursor, true, (err, result) => {\n            if (err) {\n                // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n                //       desired behavior is that a stream ends cleanly when a user explicitly closes\n                //       a client during iteration. Alternatively, we could do the \"right\" thing and\n                //       propagate the error message by removing this special case.\n                if (err.message.match(/server is closed/)) {\n                    this._cursor.close().catch(() => null);\n                    return this.push(null);\n                }\n                // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n                //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n                //       active getMore in-flight. This used to check if the cursor was killed but once\n                //       that changed to happen in cleanup legitimate errors would not destroy the\n                //       stream. There are change streams test specifically test these cases.\n                if (err.message.match(/operation was interrupted/)) {\n                    return this.push(null);\n                }\n                // NOTE: The two above checks on the message of the error will cause a null to be pushed\n                //       to the stream, thus closing the stream before the destroy call happens. This means\n                //       that either of those error messages on a change stream will not get a proper\n                //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n                //       relies on that error event to be emitted to create its new cursor and thus was not\n                //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n                //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n                //       See NODE-4475.\n                return this.destroy(err);\n            }\n            if (result == null) {\n                this.push(null);\n            }\n            else if (this.destroyed) {\n                this._cursor.close().catch(() => null);\n            }\n            else {\n                if (this.push(result)) {\n                    return this._readNext();\n                }\n                this._readInProgress = false;\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"script"}