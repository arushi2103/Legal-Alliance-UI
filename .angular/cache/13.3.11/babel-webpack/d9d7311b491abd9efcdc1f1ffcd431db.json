{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.ByteUtils = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst os = require(\"os\");\n\nconst url_1 = require(\"url\");\n\nconst bson_1 = require(\"./bson\");\n\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nconst constants_2 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nexports.ByteUtils = {\n  toLocalBufferType(buffer) {\n    return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  },\n\n  equals(seqA, seqB) {\n    return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);\n  },\n\n  compare(seqA, seqB) {\n    return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);\n  },\n\n  toBase64(uint8array) {\n    return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');\n  }\n\n};\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n\nconst TO_STRING = object => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n\n\nfunction isObject(arg) {\n  return '[object Object]' === TO_STRING(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return { ...target,\n    ...source\n  };\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options?.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The resolution type of the possible promise\n * @param value - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(value) {\n  return !!value && typeof value.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  const readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\n\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection === '' ? undefined : collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (typeof namespace !== 'string' || namespace === '') {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collectionParts] = namespace.split('.');\n    const collection = collectionParts.join('.');\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n  }\n\n}\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction* makeCounter(seed = 0) {\n  let count = seed;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\nexports.makeCounter = makeCounter;\n\nfunction maybeCallback(promiseFn, callback) {\n  const promise = promiseFn();\n\n  if (callback == null) {\n    return promise;\n  }\n\n  promise.then(result => callback(undefined, result), error => callback(error));\n  return;\n}\n\nexports.maybeCallback = maybeCallback;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is available that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  const name = options.driverInfo.name ? `nodejs|${options.driverInfo.name}` : 'nodejs';\n  const version = options.driverInfo.version ? `${NODE_DRIVER_VERSION}|${options.driverInfo.version}` : NODE_DRIVER_VERSION;\n  const platform = options.driverInfo.platform ? `Node.js ${process.version}, ${os.endianness()}|${options.driverInfo.platform}` : `Node.js ${process.version}, ${os.endianness()}`;\n  const metadata = {\n    driver: {\n      name,\n      version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform\n  };\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const name = Buffer.byteLength(options.appName, 'utf8') <= 128 ? options.appName : Buffer.from(options.appName, 'utf8').subarray(0, 128).toString('utf8');\n    metadata.application = {\n      name\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  const session = options?.session;\n\n  if (!session?.inTransaction()) {\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\n\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\n\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nconst HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\n\nfunction isRecord(value, requiredKeys = undefined) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/**\n * A sequential list of items in a circularly linked list\n * @remarks\n * The head node is special, it is always defined and has a value of null.\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\n * @internal\n */\n\nclass List {\n  get length() {\n    return this.count;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'List';\n  }\n\n  constructor() {\n    this.count = 0; // this is carefully crafted:\n    // declaring a complete and consistently key ordered\n    // object is beneficial to the runtime optimizations\n\n    this.head = {\n      next: null,\n      prev: null,\n      value: null\n    };\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n\n  toArray() {\n    return Array.from(this);\n  }\n\n  toString() {\n    return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\n  }\n\n  *[Symbol.iterator]() {\n    for (const node of this.nodes()) {\n      yield node.value;\n    }\n  }\n\n  *nodes() {\n    let ptr = this.head.next;\n\n    while (ptr !== this.head) {\n      // Save next before yielding so that we make removing within iteration safe\n      const {\n        next\n      } = ptr;\n      yield ptr;\n      ptr = next;\n    }\n  }\n  /** Insert at end of list */\n\n\n  push(value) {\n    this.count += 1;\n    const newNode = {\n      next: this.head,\n      prev: this.head.prev,\n      value\n    };\n    this.head.prev.next = newNode;\n    this.head.prev = newNode;\n  }\n  /** Inserts every item inside an iterable instead of the iterable itself */\n\n\n  pushMany(iterable) {\n    for (const value of iterable) {\n      this.push(value);\n    }\n  }\n  /** Insert at front of list */\n\n\n  unshift(value) {\n    this.count += 1;\n    const newNode = {\n      next: this.head.next,\n      prev: this.head,\n      value\n    };\n    this.head.next.prev = newNode;\n    this.head.next = newNode;\n  }\n\n  remove(node) {\n    if (node === this.head || this.length === 0) {\n      return null;\n    }\n\n    this.count -= 1;\n    const prevNode = node.prev;\n    const nextNode = node.next;\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n    return node.value;\n  }\n  /** Removes the first node at the front of the list */\n\n\n  shift() {\n    return this.remove(this.head.next);\n  }\n  /** Removes the last node at the end of the list */\n\n\n  pop() {\n    return this.remove(this.head.prev);\n  }\n  /** Iterates through the list and removes nodes where filter returns true */\n\n\n  prune(filter) {\n    for (const node of this.nodes()) {\n      if (filter(node.value)) {\n        this.remove(node);\n      }\n    }\n  }\n\n  clear() {\n    this.count = 0;\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n  /** Returns the first item in the list, does not remove */\n\n\n  first() {\n    // If the list is empty, value will be the head's null\n    return this.head.next.value;\n  }\n  /** Returns the last item in the list, does not remove */\n\n\n  last() {\n    // If the list is empty, value will be the head's null\n    return this.head.prev.value;\n  }\n\n}\n\nexports.List = List;\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nclass BufferPool {\n  constructor() {\n    this.buffers = new List();\n    this.totalByteLength = 0;\n  }\n\n  get length() {\n    return this.totalByteLength;\n  }\n  /** Adds a buffer to the internal buffer pool list */\n\n\n  append(buffer) {\n    this.buffers.push(buffer);\n    this.totalByteLength += buffer.length;\n  }\n  /**\n   * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\n   * otherwise return null. Size can be negative, caller should error check.\n   */\n\n\n  getInt32() {\n    if (this.totalByteLength < 4) {\n      return null;\n    }\n\n    const firstBuffer = this.buffers.first();\n\n    if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n      return firstBuffer.readInt32LE(0);\n    } // Unlikely case: an int32 is split across buffers.\n    // Use read and put the returned buffer back on top\n\n\n    const top4Bytes = this.read(4);\n    const value = top4Bytes.readInt32LE(0); // Put it back.\n\n    this.totalByteLength += 4;\n    this.buffers.unshift(top4Bytes);\n    return value;\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n\n\n  read(size) {\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    } // oversized request returns empty buffer\n\n\n    if (size > this.totalByteLength) {\n      return Buffer.alloc(0);\n    } // We know we have enough, we just don't know how it is spread across chunks\n    // TODO(NODE-4732): alloc API should change based on raw option\n\n\n    const result = Buffer.allocUnsafe(size);\n\n    for (let bytesRead = 0; bytesRead < size;) {\n      const buffer = this.buffers.shift();\n\n      if (buffer == null) {\n        break;\n      }\n\n      const bytesRemaining = size - bytesRead;\n      const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n      const bytes = buffer.subarray(0, bytesReadable);\n      result.set(bytes, bytesRead);\n      bytesRead += bytesReadable;\n      this.totalByteLength -= bytesReadable;\n\n      if (bytesReadable < buffer.byteLength) {\n        this.buffers.unshift(buffer.subarray(bytesReadable));\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nclass HostAddress {\n  constructor(hostString) {\n    this.host = undefined;\n    this.port = undefined;\n    this.socketPath = undefined;\n    this.isIPv6 = false;\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    if (escapedHost.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(escapedHost);\n      return;\n    }\n\n    const urlString = `iLoveJS://${escapedHost}`;\n    let url;\n\n    try {\n      url = new url_1.URL(urlString);\n    } catch (urlError) {\n      const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\n      runtimeError.cause = urlError;\n      throw runtimeError;\n    }\n\n    const hostname = url.hostname;\n    const port = url.port;\n    let normalized = decodeURIComponent(hostname).toLowerCase();\n\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\n      this.isIPv6 = true;\n      normalized = normalized.substring(1, hostname.length - 1);\n    }\n\n    this.host = normalized.toLowerCase();\n\n    if (typeof port === 'number') {\n      this.port = port;\n    } else if (typeof port === 'string' && port !== '') {\n      this.port = Number.parseInt(port, 10);\n    } else {\n      this.port = 27017;\n    }\n\n    if (this.port === 0) {\n      throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n    }\n\n    Object.freeze(this);\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n\n  inspect() {\n    return `new HostAddress('${this.toString()}')`;\n  }\n\n  toString() {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6) {\n        return `[${this.host}]:${this.port}`;\n      }\n\n      return `${this.host}:${this.port}`;\n    }\n\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n\n  static fromHostPort(host, port) {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n\n  static fromSrvRecord({\n    name,\n    port\n  }) {\n    return HostAddress.fromHostPort(name, port);\n  }\n\n}\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```ts\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n/**\n * Fisherâ€“Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\n\nfunction shuffle(sequence, limit = 0) {\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1; // And swap it with the current element\n\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\nexports.shuffle = shuffle; // TODO(NODE-4936): read concern eligibility for commands should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\n\nfunction getMongoDBClientEncryption() {\n  let mongodbClientEncryption = null; // NOTE(NODE-4254): This is to get around the circular dependency between\n  // mongodb-client-encryption and the driver in the test scenarios.\n\n  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n    } catch {// ignore\n    }\n  } else {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require('mongodb-client-encryption');\n    } catch {// ignore\n    }\n  }\n\n  return mongodbClientEncryption;\n}\n\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;\n/**\n * Compare objectIds. `null` is always less\n * - `+1 = oid1 is greater than oid2`\n * - `-1 = oid1 is less than oid2`\n * - `+0 = oid1 is equal oid2`\n */\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null && oid2 == null) {\n    return 0;\n  }\n\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  return exports.ByteUtils.compare(oid1.id, oid2.id);\n}\n\nexports.compareObjectId = compareObjectId;\n\nfunction parseInteger(value) {\n  if (typeof value === 'number') return Math.trunc(value);\n  const parsedValue = Number.parseInt(String(value), 10);\n  return Number.isNaN(parsedValue) ? null : parsedValue;\n}\n\nexports.parseInteger = parseInteger;\n\nfunction parseUnsignedInteger(value) {\n  const parsedInt = parseInteger(value);\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\n\nexports.parseUnsignedInteger = parseUnsignedInteger;","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/utils.js"],"names":["Object","defineProperty","exports","value","parseUnsignedInteger","parseInteger","compareObjectId","getMongoDBClientEncryption","commandSupportsReadConcern","shuffle","supportsRetryableWrites","enumToString","emitWarningOnce","emitWarning","MONGODB_WARNING_CODE","DEFAULT_PK_FACTORY","HostAddress","BufferPool","List","deepCopy","isRecord","setDifference","isHello","isSuperset","resolveOptions","hasAtomicOperators","calculateDurationInMs","now","makeClientMetadata","makeStateMachine","errorStrictEqual","arrayStrictEqual","eachAsync","maxWireVersion","uuidV4","databaseNamespace","maybeCallback","makeCounter","MongoDBNamespace","ns","getTopology","decorateWithExplain","decorateWithReadConcern","decorateWithCollation","isPromiseLike","applyRetryableWrites","filterOptions","mergeOptions","isObject","normalizeHintField","checkCollectionName","ByteUtils","crypto","require","os","url_1","bson_1","constants_1","constants_2","error_1","read_concern_1","read_preference_1","common_1","write_concern_1","toLocalBufferType","buffer","Buffer","isBuffer","from","byteOffset","byteLength","equals","seqA","seqB","compare","toBase64","uint8array","toString","collectionName","MongoInvalidArgumentError","indexOf","match","hint","finalHint","undefined","Array","isArray","forEach","param","name","TO_STRING","object","prototype","call","arg","target","source","options","names","includes","db","s","retryWrites","then","command","capabilities","collation","commandsTakeCollation","MongoCompatibilityError","coll","session","inTransaction","readConcern","assign","keys","length","explain","verbosity","provider","topology","client","MongoNotConnectedError","fromString","constructor","collection","withCollection","namespace","MongoRuntimeError","collectionParts","split","join","seed","count","newCount","promiseFn","callback","promise","result","error","randomBytes","topologyOrServer","loadBalanced","MAX_SUPPORTED_WIRE_VERSION","hello","lastHello","description","arr","eachFn","idx","awaiting","eachCallback","err","arr2","every","elt","lhs","rhs","message","stateTable","stateTransition","newState","legalStates","state","emit","NODE_DRIVER_VERSION","version","driverInfo","platform","process","endianness","metadata","driver","type","architecture","arch","release","appName","subarray","application","hrtime","Math","floor","started","elapsed","doc","document","parent","resolveBSONOptions","ReadConcern","fromOptions","writeConcern","WriteConcern","readPreference","ReadPreference","set","subset","Set","elem","has","LEGACY_HELLO_COMMAND","setA","setB","difference","delete","HAS_OWN","prop","hasOwnProperty","requiredKeys","ctor","map","item","res","key","toLowerCase","Number","Map","Symbol","toStringTag","head","next","prev","toArray","iterator","node","nodes","ptr","push","newNode","pushMany","iterable","unshift","remove","prevNode","nextNode","shift","pop","prune","filter","clear","first","last","buffers","totalByteLength","append","getInt32","firstBuffer","readInt32LE","top4Bytes","read","size","alloc","allocUnsafe","bytesRead","bytesRemaining","bytesReadable","min","bytes","hostString","host","port","socketPath","isIPv6","escapedHost","endsWith","decodeURIComponent","urlString","url","URL","urlError","runtimeError","cause","hostname","normalized","startsWith","substring","parseInt","MongoParseError","freeze","for","inspect","fromHostPort","fromSrvRecord","createPk","ObjectId","code","emittedWarnings","add","en","values","server","logicalSessionTimeoutMinutes","ServerType","Standalone","sequence","limit","items","remainingItemsToShuffle","lowerBound","randomIndex","random","swapHold","slice","aggregate","distinct","find","geoNear","mapReduce","out","inline","mongodbClientEncryption","env","MONGODB_CLIENT_ENCRYPTION_OVERRIDE","oid1","oid2","id","trunc","parsedValue","String","isNaN","parsedInt"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,oBAAR,GAA+BF,OAAO,CAACG,YAAR,GAAuBH,OAAO,CAACI,eAAR,GAA0BJ,OAAO,CAACK,0BAAR,GAAqCL,OAAO,CAACM,0BAAR,GAAqCN,OAAO,CAACO,OAAR,GAAkBP,OAAO,CAACQ,uBAAR,GAAkCR,OAAO,CAACS,YAAR,GAAuBT,OAAO,CAACU,eAAR,GAA0BV,OAAO,CAACW,WAAR,GAAsBX,OAAO,CAACY,oBAAR,GAA+BZ,OAAO,CAACa,kBAAR,GAA6Bb,OAAO,CAACc,WAAR,GAAsBd,OAAO,CAACe,UAAR,GAAqBf,OAAO,CAACgB,IAAR,GAAehB,OAAO,CAACiB,QAAR,GAAmBjB,OAAO,CAACkB,QAAR,GAAmBlB,OAAO,CAACmB,aAAR,GAAwBnB,OAAO,CAACoB,OAAR,GAAkBpB,OAAO,CAACqB,UAAR,GAAqBrB,OAAO,CAACsB,cAAR,GAAyBtB,OAAO,CAACuB,kBAAR,GAA6BvB,OAAO,CAACwB,qBAAR,GAAgCxB,OAAO,CAACyB,GAAR,GAAczB,OAAO,CAAC0B,kBAAR,GAA6B1B,OAAO,CAAC2B,gBAAR,GAA2B3B,OAAO,CAAC4B,gBAAR,GAA2B5B,OAAO,CAAC6B,gBAAR,GAA2B7B,OAAO,CAAC8B,SAAR,GAAoB9B,OAAO,CAAC+B,cAAR,GAAyB/B,OAAO,CAACgC,MAAR,GAAiBhC,OAAO,CAACiC,iBAAR,GAA4BjC,OAAO,CAACkC,aAAR,GAAwBlC,OAAO,CAACmC,WAAR,GAAsBnC,OAAO,CAACoC,gBAAR,GAA2BpC,OAAO,CAACqC,EAAR,GAAarC,OAAO,CAACsC,WAAR,GAAsBtC,OAAO,CAACuC,mBAAR,GAA8BvC,OAAO,CAACwC,uBAAR,GAAkCxC,OAAO,CAACyC,qBAAR,GAAgCzC,OAAO,CAAC0C,aAAR,GAAwB1C,OAAO,CAAC2C,oBAAR,GAA+B3C,OAAO,CAAC4C,aAAR,GAAwB5C,OAAO,CAAC6C,YAAR,GAAuB7C,OAAO,CAAC8C,QAAR,GAAmB9C,OAAO,CAAC+C,kBAAR,GAA6B/C,OAAO,CAACgD,mBAAR,GAA8BhD,OAAO,CAACiD,SAAR,GAAoB,KAAK,CAArrC;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,KAAD,CAArB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,gCAAD,CAA3B;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAMQ,iBAAiB,GAAGR,OAAO,CAAC,mBAAD,CAAjC;;AACA,MAAMS,QAAQ,GAAGT,OAAO,CAAC,eAAD,CAAxB;;AACA,MAAMU,eAAe,GAAGV,OAAO,CAAC,iBAAD,CAA/B;;AACAnD,OAAO,CAACiD,SAAR,GAAoB;AAChBa,EAAAA,iBAAiB,CAACC,MAAD,EAAS;AACtB,WAAOC,MAAM,CAACC,QAAP,CAAgBF,MAAhB,IACDA,MADC,GAEDC,MAAM,CAACE,IAAP,CAAYH,MAAM,CAACA,MAAnB,EAA2BA,MAAM,CAACI,UAAlC,EAA8CJ,MAAM,CAACK,UAArD,CAFN;AAGH,GALe;;AAMhBC,EAAAA,MAAM,CAACC,IAAD,EAAOC,IAAP,EAAa;AACf,WAAOvE,OAAO,CAACiD,SAAR,CAAkBa,iBAAlB,CAAoCQ,IAApC,EAA0CD,MAA1C,CAAiDE,IAAjD,CAAP;AACH,GARe;;AAShBC,EAAAA,OAAO,CAACF,IAAD,EAAOC,IAAP,EAAa;AAChB,WAAOvE,OAAO,CAACiD,SAAR,CAAkBa,iBAAlB,CAAoCQ,IAApC,EAA0CE,OAA1C,CAAkDD,IAAlD,CAAP;AACH,GAXe;;AAYhBE,EAAAA,QAAQ,CAACC,UAAD,EAAa;AACjB,WAAO1E,OAAO,CAACiD,SAAR,CAAkBa,iBAAlB,CAAoCY,UAApC,EAAgDC,QAAhD,CAAyD,QAAzD,CAAP;AACH;;AAde,CAApB;AAgBA;AACA;AACA;AACA;;AACA,SAAS3B,mBAAT,CAA6B4B,cAA7B,EAA6C;AACzC,MAAI,aAAa,OAAOA,cAAxB,EAAwC;AACpC,UAAM,IAAInB,OAAO,CAACoB,yBAAZ,CAAsC,kCAAtC,CAAN;AACH;;AACD,MAAI,CAACD,cAAD,IAAmBA,cAAc,CAACE,OAAf,CAAuB,IAAvB,MAAiC,CAAC,CAAzD,EAA4D;AACxD,UAAM,IAAIrB,OAAO,CAACoB,yBAAZ,CAAsC,kCAAtC,CAAN;AACH;;AACD,MAAID,cAAc,CAACE,OAAf,CAAuB,GAAvB,MAAgC,CAAC,CAAjC,IACAF,cAAc,CAACG,KAAf,CAAqB,4BAArB,KAAsD,IAD1D,EACgE;AAC5D;AACA,UAAM,IAAItB,OAAO,CAACoB,yBAAZ,CAAsC,uCAAtC,CAAN;AACH;;AACD,MAAID,cAAc,CAACG,KAAf,CAAqB,SAArB,KAAmC,IAAvC,EAA6C;AACzC;AACA,UAAM,IAAItB,OAAO,CAACoB,yBAAZ,CAAsC,iDAAtC,CAAN;AACH,GAfwC,CAgBzC;;;AACA,MAAID,cAAc,CAACE,OAAf,CAAuB,MAAvB,MAAmC,CAAC,CAAxC,EAA2C;AACvC;AACA,UAAM,IAAIrB,OAAO,CAACoB,yBAAZ,CAAsC,kDAAtC,CAAN;AACH;AACJ;;AACD7E,OAAO,CAACgD,mBAAR,GAA8BA,mBAA9B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,kBAAT,CAA4BiC,IAA5B,EAAkC;AAC9B,MAAIC,SAAS,GAAGC,SAAhB;;AACA,MAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC1BC,IAAAA,SAAS,GAAGD,IAAZ;AACH,GAFD,MAGK,IAAIG,KAAK,CAACC,OAAN,CAAcJ,IAAd,CAAJ,EAAyB;AAC1BC,IAAAA,SAAS,GAAG,EAAZ;AACAD,IAAAA,IAAI,CAACK,OAAL,CAAaC,KAAK,IAAI;AAClBL,MAAAA,SAAS,CAACK,KAAD,CAAT,GAAmB,CAAnB;AACH,KAFD;AAGH,GALI,MAMA,IAAIN,IAAI,IAAI,IAAR,IAAgB,OAAOA,IAAP,KAAgB,QAApC,EAA8C;AAC/CC,IAAAA,SAAS,GAAG,EAAZ;;AACA,SAAK,MAAMM,IAAX,IAAmBP,IAAnB,EAAyB;AACrBC,MAAAA,SAAS,CAACM,IAAD,CAAT,GAAkBP,IAAI,CAACO,IAAD,CAAtB;AACH;AACJ;;AACD,SAAON,SAAP;AACH;;AACDjF,OAAO,CAAC+C,kBAAR,GAA6BA,kBAA7B;;AACA,MAAMyC,SAAS,GAAIC,MAAD,IAAY3F,MAAM,CAAC4F,SAAP,CAAiBf,QAAjB,CAA0BgB,IAA1B,CAA+BF,MAA/B,CAA9B;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS3C,QAAT,CAAkB8C,GAAlB,EAAuB;AACnB,SAAO,sBAAsBJ,SAAS,CAACI,GAAD,CAAtC;AACH;;AACD5F,OAAO,CAAC8C,QAAR,GAAmBA,QAAnB;AACA;;AACA,SAASD,YAAT,CAAsBgD,MAAtB,EAA8BC,MAA9B,EAAsC;AAClC,SAAO,EAAE,GAAGD,MAAL;AAAa,OAAGC;AAAhB,GAAP;AACH;;AACD9F,OAAO,CAAC6C,YAAR,GAAuBA,YAAvB;AACA;;AACA,SAASD,aAAT,CAAuBmD,OAAvB,EAAgCC,KAAhC,EAAuC;AACnC,QAAMpD,aAAa,GAAG,EAAtB;;AACA,OAAK,MAAM2C,IAAX,IAAmBQ,OAAnB,EAA4B;AACxB,QAAIC,KAAK,CAACC,QAAN,CAAeV,IAAf,CAAJ,EAA0B;AACtB3C,MAAAA,aAAa,CAAC2C,IAAD,CAAb,GAAsBQ,OAAO,CAACR,IAAD,CAA7B;AACH;AACJ,GANkC,CAOnC;;;AACA,SAAO3C,aAAP;AACH;;AACD5C,OAAO,CAAC4C,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,oBAAT,CAA8BkD,MAA9B,EAAsCK,EAAtC,EAA0C;AACtC,MAAIA,EAAE,IAAIA,EAAE,CAACC,CAAH,CAAKJ,OAAL,EAAcK,WAAxB,EAAqC;AACjCP,IAAAA,MAAM,CAACO,WAAP,GAAqB,IAArB;AACH;;AACD,SAAOP,MAAP;AACH;;AACD7F,OAAO,CAAC2C,oBAAR,GAA+BA,oBAA/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,aAAT,CAAuBzC,KAAvB,EAA8B;AAC1B,SAAO,CAAC,CAACA,KAAF,IAAW,OAAOA,KAAK,CAACoG,IAAb,KAAsB,UAAxC;AACH;;AACDrG,OAAO,CAAC0C,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,qBAAT,CAA+B6D,OAA/B,EAAwCT,MAAxC,EAAgDE,OAAhD,EAAyD;AACrD,QAAMQ,YAAY,GAAGjE,WAAW,CAACuD,MAAD,CAAX,CAAoBU,YAAzC;;AACA,MAAIR,OAAO,CAACS,SAAR,IAAqB,OAAOT,OAAO,CAACS,SAAf,KAA6B,QAAtD,EAAgE;AAC5D,QAAID,YAAY,IAAIA,YAAY,CAACE,qBAAjC,EAAwD;AACpDH,MAAAA,OAAO,CAACE,SAAR,GAAoBT,OAAO,CAACS,SAA5B;AACH,KAFD,MAGK;AACD,YAAM,IAAI/C,OAAO,CAACiD,uBAAZ,CAAqC,6CAArC,CAAN;AACH;AACJ;AACJ;;AACD1G,OAAO,CAACyC,qBAAR,GAAgCA,qBAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,uBAAT,CAAiC8D,OAAjC,EAA0CK,IAA1C,EAAgDZ,OAAhD,EAAyD;AACrD,MAAIA,OAAO,IAAIA,OAAO,CAACa,OAAnB,IAA8Bb,OAAO,CAACa,OAAR,CAAgBC,aAAhB,EAAlC,EAAmE;AAC/D;AACH;;AACD,QAAMC,WAAW,GAAGhH,MAAM,CAACiH,MAAP,CAAc,EAAd,EAAkBT,OAAO,CAACQ,WAAR,IAAuB,EAAzC,CAApB;;AACA,MAAIH,IAAI,CAACR,CAAL,CAAOW,WAAX,EAAwB;AACpBhH,IAAAA,MAAM,CAACiH,MAAP,CAAcD,WAAd,EAA2BH,IAAI,CAACR,CAAL,CAAOW,WAAlC;AACH;;AACD,MAAIhH,MAAM,CAACkH,IAAP,CAAYF,WAAZ,EAAyBG,MAAzB,GAAkC,CAAtC,EAAyC;AACrCnH,IAAAA,MAAM,CAACiH,MAAP,CAAcT,OAAd,EAAuB;AAAEQ,MAAAA,WAAW,EAAEA;AAAf,KAAvB;AACH;AACJ;;AACD9G,OAAO,CAACwC,uBAAR,GAAkCA,uBAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,mBAAT,CAA6B+D,OAA7B,EAAsCY,OAAtC,EAA+C;AAC3C,MAAIZ,OAAO,CAACY,OAAZ,EAAqB;AACjB,WAAOZ,OAAP;AACH;;AACD,SAAO;AAAEY,IAAAA,OAAO,EAAEZ,OAAX;AAAoBa,IAAAA,SAAS,EAAED,OAAO,CAACC;AAAvC,GAAP;AACH;;AACDnH,OAAO,CAACuC,mBAAR,GAA8BA,mBAA9B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,WAAT,CAAqB8E,QAArB,EAA+B;AAC3B;AACA,MAAI,cAAcA,QAAd,IAA0BA,QAAQ,CAACC,QAAvC,EAAiD;AAC7C,WAAOD,QAAQ,CAACC,QAAhB;AACH,GAFD,MAGK,IAAI,OAAOD,QAAP,IAAmB,YAAYA,QAAQ,CAACjB,CAAxC,IAA6CiB,QAAQ,CAACjB,CAAT,CAAWmB,MAAX,CAAkBD,QAAnE,EAA6E;AAC9E,WAAOD,QAAQ,CAACjB,CAAT,CAAWmB,MAAX,CAAkBD,QAAzB;AACH,GAFI,MAGA,IAAI,OAAOD,QAAP,IAAmB,QAAQA,QAAQ,CAACjB,CAApC,IAAyCiB,QAAQ,CAACjB,CAAT,CAAWD,EAAX,CAAcC,CAAd,CAAgBmB,MAAhB,CAAuBD,QAApE,EAA8E;AAC/E,WAAOD,QAAQ,CAACjB,CAAT,CAAWD,EAAX,CAAcC,CAAd,CAAgBmB,MAAhB,CAAuBD,QAA9B;AACH;;AACD,QAAM,IAAI5D,OAAO,CAAC8D,sBAAZ,CAAmC,yDAAnC,CAAN;AACH;;AACDvH,OAAO,CAACsC,WAAR,GAAsBA,WAAtB;AACA;;AACA,SAASD,EAAT,CAAYA,EAAZ,EAAgB;AACZ,SAAOD,gBAAgB,CAACoF,UAAjB,CAA4BnF,EAA5B,CAAP;AACH;;AACDrC,OAAO,CAACqC,EAAR,GAAaA,EAAb;AACA;;AACA,MAAMD,gBAAN,CAAuB;AACnB;AACJ;AACA;AACA;AACA;AACA;AACIqF,EAAAA,WAAW,CAACvB,EAAD,EAAKwB,UAAL,EAAiB;AACxB,SAAKxB,EAAL,GAAUA,EAAV;AACA,SAAKwB,UAAL,GAAkBA,UAAU,KAAK,EAAf,GAAoBxC,SAApB,GAAgCwC,UAAlD;AACH;;AACD/C,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAK+C,UAAL,GAAmB,GAAE,KAAKxB,EAAG,IAAG,KAAKwB,UAAW,EAAhD,GAAoD,KAAKxB,EAAhE;AACH;;AACDyB,EAAAA,cAAc,CAACD,UAAD,EAAa;AACvB,WAAO,IAAItF,gBAAJ,CAAqB,KAAK8D,EAA1B,EAA8BwB,UAA9B,CAAP;AACH;;AACgB,SAAVF,UAAU,CAACI,SAAD,EAAY;AACzB,QAAI,OAAOA,SAAP,KAAqB,QAArB,IAAiCA,SAAS,KAAK,EAAnD,EAAuD;AACnD;AACA,YAAM,IAAInE,OAAO,CAACoE,iBAAZ,CAA+B,gCAA+BD,SAAU,GAAxE,CAAN;AACH;;AACD,UAAM,CAAC1B,EAAD,EAAK,GAAG4B,eAAR,IAA2BF,SAAS,CAACG,KAAV,CAAgB,GAAhB,CAAjC;AACA,UAAML,UAAU,GAAGI,eAAe,CAACE,IAAhB,CAAqB,GAArB,CAAnB;AACA,WAAO,IAAI5F,gBAAJ,CAAqB8D,EAArB,EAAyBwB,UAAU,KAAK,EAAf,GAAoBxC,SAApB,GAAgCwC,UAAzD,CAAP;AACH;;AAzBkB;;AA2BvB1H,OAAO,CAACoC,gBAAR,GAA2BA,gBAA3B;AACA;;AACA,UAAUD,WAAV,CAAsB8F,IAAI,GAAG,CAA7B,EAAgC;AAC5B,MAAIC,KAAK,GAAGD,IAAZ;;AACA,SAAO,IAAP,EAAa;AACT,UAAME,QAAQ,GAAGD,KAAjB;AACAA,IAAAA,KAAK,IAAI,CAAT;AACA,UAAMC,QAAN;AACH;AACJ;;AACDnI,OAAO,CAACmC,WAAR,GAAsBA,WAAtB;;AACA,SAASD,aAAT,CAAuBkG,SAAvB,EAAkCC,QAAlC,EAA4C;AACxC,QAAMC,OAAO,GAAGF,SAAS,EAAzB;;AACA,MAAIC,QAAQ,IAAI,IAAhB,EAAsB;AAClB,WAAOC,OAAP;AACH;;AACDA,EAAAA,OAAO,CAACjC,IAAR,CAAakC,MAAM,IAAIF,QAAQ,CAACnD,SAAD,EAAYqD,MAAZ,CAA/B,EAAoDC,KAAK,IAAIH,QAAQ,CAACG,KAAD,CAArE;AACA;AACH;;AACDxI,OAAO,CAACkC,aAAR,GAAwBA,aAAxB;AACA;;AACA,SAASD,iBAAT,CAA2BI,EAA3B,EAA+B;AAC3B,SAAOA,EAAE,CAAC0F,KAAH,CAAS,GAAT,EAAc,CAAd,CAAP;AACH;;AACD/H,OAAO,CAACiC,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;AACA;;AACA,SAASD,MAAT,GAAkB;AACd,QAAMuG,MAAM,GAAGrF,MAAM,CAACuF,WAAP,CAAmB,EAAnB,CAAf;AACAF,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAaA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAb,GAAqB,IAAjC;AACAA,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAaA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAb,GAAqB,IAAjC;AACA,SAAOA,MAAP;AACH;;AACDvI,OAAO,CAACgC,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;;AACA,SAASD,cAAT,CAAwB2G,gBAAxB,EAA0C;AACtC,MAAIA,gBAAJ,EAAsB;AAClB,QAAIA,gBAAgB,CAACC,YAArB,EAAmC;AAC/B;AACA;AACA;AACA;AACA,aAAOpF,WAAW,CAACqF,0BAAnB;AACH;;AACD,QAAIF,gBAAgB,CAACG,KAArB,EAA4B;AACxB,aAAOH,gBAAgB,CAACG,KAAjB,CAAuB9G,cAA9B;AACH;;AACD,QAAI,eAAe2G,gBAAf,IAAmC,OAAOA,gBAAgB,CAACI,SAAxB,KAAsC,UAA7E,EAAyF;AACrF,YAAMA,SAAS,GAAGJ,gBAAgB,CAACI,SAAjB,EAAlB;;AACA,UAAIA,SAAJ,EAAe;AACX,eAAOA,SAAS,CAAC/G,cAAjB;AACH;AACJ;;AACD,QAAI2G,gBAAgB,CAACK,WAAjB,IACA,oBAAoBL,gBAAgB,CAACK,WADrC,IAEAL,gBAAgB,CAACK,WAAjB,CAA6BhH,cAA7B,IAA+C,IAFnD,EAEyD;AACrD,aAAO2G,gBAAgB,CAACK,WAAjB,CAA6BhH,cAApC;AACH;AACJ;;AACD,SAAO,CAAP;AACH;;AACD/B,OAAO,CAAC+B,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,SAAT,CAAmBkH,GAAnB,EAAwBC,MAAxB,EAAgCZ,QAAhC,EAA0C;AACtCW,EAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,MAAIE,GAAG,GAAG,CAAV;AACA,MAAIC,QAAQ,GAAG,CAAf;;AACA,OAAKD,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGF,GAAG,CAAC/B,MAAxB,EAAgC,EAAEiC,GAAlC,EAAuC;AACnCC,IAAAA,QAAQ;AACRF,IAAAA,MAAM,CAACD,GAAG,CAACE,GAAD,CAAJ,EAAWE,YAAX,CAAN;AACH;;AACD,MAAID,QAAQ,KAAK,CAAjB,EAAoB;AAChBd,IAAAA,QAAQ;AACR;AACH;;AACD,WAASe,YAAT,CAAsBC,GAAtB,EAA2B;AACvBF,IAAAA,QAAQ;;AACR,QAAIE,GAAJ,EAAS;AACLhB,MAAAA,QAAQ,CAACgB,GAAD,CAAR;AACA;AACH;;AACD,QAAIH,GAAG,KAAKF,GAAG,CAAC/B,MAAZ,IAAsBkC,QAAQ,IAAI,CAAtC,EAAyC;AACrCd,MAAAA,QAAQ;AACX;AACJ;AACJ;;AACDrI,OAAO,CAAC8B,SAAR,GAAoBA,SAApB;AACA;;AACA,SAASD,gBAAT,CAA0BmH,GAA1B,EAA+BM,IAA/B,EAAqC;AACjC,MAAI,CAACnE,KAAK,CAACC,OAAN,CAAc4D,GAAd,CAAD,IAAuB,CAAC7D,KAAK,CAACC,OAAN,CAAckE,IAAd,CAA5B,EAAiD;AAC7C,WAAO,KAAP;AACH;;AACD,SAAON,GAAG,CAAC/B,MAAJ,KAAeqC,IAAI,CAACrC,MAApB,IAA8B+B,GAAG,CAACO,KAAJ,CAAU,CAACC,GAAD,EAAMN,GAAN,KAAcM,GAAG,KAAKF,IAAI,CAACJ,GAAD,CAApC,CAArC;AACH;;AACDlJ,OAAO,CAAC6B,gBAAR,GAA2BA,gBAA3B;AACA;;AACA,SAASD,gBAAT,CAA0B6H,GAA1B,EAA+BC,GAA/B,EAAoC;AAChC,MAAID,GAAG,KAAKC,GAAZ,EAAiB;AACb,WAAO,IAAP;AACH;;AACD,MAAI,CAACD,GAAD,IAAQ,CAACC,GAAb,EAAkB;AACd,WAAOD,GAAG,KAAKC,GAAf;AACH;;AACD,MAAKD,GAAG,IAAI,IAAP,IAAeC,GAAG,IAAI,IAAvB,IAAiCD,GAAG,IAAI,IAAP,IAAeC,GAAG,IAAI,IAA3D,EAAkE;AAC9D,WAAO,KAAP;AACH;;AACD,MAAID,GAAG,CAAChC,WAAJ,CAAgBlC,IAAhB,KAAyBmE,GAAG,CAACjC,WAAJ,CAAgBlC,IAA7C,EAAmD;AAC/C,WAAO,KAAP;AACH;;AACD,MAAIkE,GAAG,CAACE,OAAJ,KAAgBD,GAAG,CAACC,OAAxB,EAAiC;AAC7B,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH;;AACD3J,OAAO,CAAC4B,gBAAR,GAA2BA,gBAA3B;AACA;;AACA,SAASD,gBAAT,CAA0BiI,UAA1B,EAAsC;AAClC,SAAO,SAASC,eAAT,CAAyBhE,MAAzB,EAAiCiE,QAAjC,EAA2C;AAC9C,UAAMC,WAAW,GAAGH,UAAU,CAAC/D,MAAM,CAACM,CAAP,CAAS6D,KAAV,CAA9B;;AACA,QAAID,WAAW,IAAIA,WAAW,CAACjF,OAAZ,CAAoBgF,QAApB,IAAgC,CAAnD,EAAsD;AAClD,YAAM,IAAIrG,OAAO,CAACoE,iBAAZ,CAA+B,kCAAiChC,MAAM,CAACM,CAAP,CAAS6D,KAAM,SAAQF,QAAS,gBAAeC,WAAY,GAA3H,CAAN;AACH;;AACDlE,IAAAA,MAAM,CAACoE,IAAP,CAAY,cAAZ,EAA4BpE,MAAM,CAACM,CAAP,CAAS6D,KAArC,EAA4CF,QAA5C;AACAjE,IAAAA,MAAM,CAACM,CAAP,CAAS6D,KAAT,GAAiBF,QAAjB;AACH,GAPD;AAQH;;AACD9J,OAAO,CAAC2B,gBAAR,GAA2BA,gBAA3B,C,CACA;;AACA,MAAMuI,mBAAmB,GAAG/G,OAAO,CAAC,iBAAD,CAAP,CAA2BgH,OAAvD;;AACA,SAASzI,kBAAT,CAA4BqE,OAA5B,EAAqC;AACjC,QAAMR,IAAI,GAAGQ,OAAO,CAACqE,UAAR,CAAmB7E,IAAnB,GAA2B,UAASQ,OAAO,CAACqE,UAAR,CAAmB7E,IAAK,EAA5D,GAAgE,QAA7E;AACA,QAAM4E,OAAO,GAAGpE,OAAO,CAACqE,UAAR,CAAmBD,OAAnB,GACT,GAAED,mBAAoB,IAAGnE,OAAO,CAACqE,UAAR,CAAmBD,OAAQ,EAD3C,GAEVD,mBAFN;AAGA,QAAMG,QAAQ,GAAGtE,OAAO,CAACqE,UAAR,CAAmBC,QAAnB,GACV,WAAUC,OAAO,CAACH,OAAQ,KAAI/G,EAAE,CAACmH,UAAH,EAAgB,IAAGxE,OAAO,CAACqE,UAAR,CAAmBC,QAAS,EADnE,GAEV,WAAUC,OAAO,CAACH,OAAQ,KAAI/G,EAAE,CAACmH,UAAH,EAAgB,EAFrD;AAGA,QAAMC,QAAQ,GAAG;AACbC,IAAAA,MAAM,EAAE;AACJlF,MAAAA,IADI;AAEJ4E,MAAAA;AAFI,KADK;AAKb/G,IAAAA,EAAE,EAAE;AACAsH,MAAAA,IAAI,EAAEtH,EAAE,CAACsH,IAAH,EADN;AAEAnF,MAAAA,IAAI,EAAE+E,OAAO,CAACD,QAFd;AAGAM,MAAAA,YAAY,EAAEL,OAAO,CAACM,IAHtB;AAIAT,MAAAA,OAAO,EAAE/G,EAAE,CAACyH,OAAH;AAJT,KALS;AAWbR,IAAAA;AAXa,GAAjB;;AAaA,MAAItE,OAAO,CAAC+E,OAAZ,EAAqB;AACjB;AACA,UAAMvF,IAAI,GAAGvB,MAAM,CAACI,UAAP,CAAkB2B,OAAO,CAAC+E,OAA1B,EAAmC,MAAnC,KAA8C,GAA9C,GACP/E,OAAO,CAAC+E,OADD,GAEP9G,MAAM,CAACE,IAAP,CAAY6B,OAAO,CAAC+E,OAApB,EAA6B,MAA7B,EAAqCC,QAArC,CAA8C,CAA9C,EAAiD,GAAjD,EAAsDpG,QAAtD,CAA+D,MAA/D,CAFN;AAGA6F,IAAAA,QAAQ,CAACQ,WAAT,GAAuB;AAAEzF,MAAAA;AAAF,KAAvB;AACH;;AACD,SAAOiF,QAAP;AACH;;AACDxK,OAAO,CAAC0B,kBAAR,GAA6BA,kBAA7B;AACA;;AACA,SAASD,GAAT,GAAe;AACX,QAAMwJ,MAAM,GAAGX,OAAO,CAACW,MAAR,EAAf;AACA,SAAOC,IAAI,CAACC,KAAL,CAAWF,MAAM,CAAC,CAAD,CAAN,GAAY,IAAZ,GAAmBA,MAAM,CAAC,CAAD,CAAN,GAAY,OAA1C,CAAP;AACH;;AACDjL,OAAO,CAACyB,GAAR,GAAcA,GAAd;AACA;;AACA,SAASD,qBAAT,CAA+B4J,OAA/B,EAAwC;AACpC,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,UAAM,IAAI3H,OAAO,CAACoB,yBAAZ,CAAsC,8CAAtC,CAAN;AACH;;AACD,QAAMwG,OAAO,GAAG5J,GAAG,KAAK2J,OAAxB;AACA,SAAOC,OAAO,GAAG,CAAV,GAAc,CAAd,GAAkBA,OAAzB;AACH;;AACDrL,OAAO,CAACwB,qBAAR,GAAgCA,qBAAhC;AACA;;AACA,SAASD,kBAAT,CAA4B+J,GAA5B,EAAiC;AAC7B,MAAInG,KAAK,CAACC,OAAN,CAAckG,GAAd,CAAJ,EAAwB;AACpB,SAAK,MAAMC,QAAX,IAAuBD,GAAvB,EAA4B;AACxB,UAAI/J,kBAAkB,CAACgK,QAAD,CAAtB,EAAkC;AAC9B,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH;;AACD,QAAMvE,IAAI,GAAGlH,MAAM,CAACkH,IAAP,CAAYsE,GAAZ,CAAb;AACA,SAAOtE,IAAI,CAACC,MAAL,GAAc,CAAd,IAAmBD,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,MAAe,GAAzC;AACH;;AACDhH,OAAO,CAACuB,kBAAR,GAA6BA,kBAA7B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,cAAT,CAAwBkK,MAAxB,EAAgCzF,OAAhC,EAAyC;AACrC,QAAMwC,MAAM,GAAGzI,MAAM,CAACiH,MAAP,CAAc,EAAd,EAAkBhB,OAAlB,EAA2B,CAAC,GAAGzC,MAAM,CAACmI,kBAAX,EAA+B1F,OAA/B,EAAwCyF,MAAxC,CAA3B,CAAf,CADqC,CAErC;;AACA,QAAM5E,OAAO,GAAGb,OAAO,EAAEa,OAAzB;;AACA,MAAI,CAACA,OAAO,EAAEC,aAAT,EAAL,EAA+B;AAC3B,UAAMC,WAAW,GAAGpD,cAAc,CAACgI,WAAf,CAA2BC,WAA3B,CAAuC5F,OAAvC,KAAmDyF,MAAM,EAAE1E,WAA/E;;AACA,QAAIA,WAAJ,EAAiB;AACbyB,MAAAA,MAAM,CAACzB,WAAP,GAAqBA,WAArB;AACH;;AACD,UAAM8E,YAAY,GAAG/H,eAAe,CAACgI,YAAhB,CAA6BF,WAA7B,CAAyC5F,OAAzC,KAAqDyF,MAAM,EAAEI,YAAlF;;AACA,QAAIA,YAAJ,EAAkB;AACdrD,MAAAA,MAAM,CAACqD,YAAP,GAAsBA,YAAtB;AACH;AACJ;;AACD,QAAME,cAAc,GAAGnI,iBAAiB,CAACoI,cAAlB,CAAiCJ,WAAjC,CAA6C5F,OAA7C,KAAyDyF,MAAM,EAAEM,cAAxF;;AACA,MAAIA,cAAJ,EAAoB;AAChBvD,IAAAA,MAAM,CAACuD,cAAP,GAAwBA,cAAxB;AACH;;AACD,SAAOvD,MAAP;AACH;;AACDvI,OAAO,CAACsB,cAAR,GAAyBA,cAAzB;;AACA,SAASD,UAAT,CAAoB2K,GAApB,EAAyBC,MAAzB,EAAiC;AAC7BD,EAAAA,GAAG,GAAG7G,KAAK,CAACC,OAAN,CAAc4G,GAAd,IAAqB,IAAIE,GAAJ,CAAQF,GAAR,CAArB,GAAoCA,GAA1C;AACAC,EAAAA,MAAM,GAAG9G,KAAK,CAACC,OAAN,CAAc6G,MAAd,IAAwB,IAAIC,GAAJ,CAAQD,MAAR,CAAxB,GAA0CA,MAAnD;;AACA,OAAK,MAAME,IAAX,IAAmBF,MAAnB,EAA2B;AACvB,QAAI,CAACD,GAAG,CAACI,GAAJ,CAAQD,IAAR,CAAL,EAAoB;AAChB,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;;AACDnM,OAAO,CAACqB,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;;AACA,SAASD,OAAT,CAAiBkK,GAAjB,EAAsB;AAClB,SAAOA,GAAG,CAAC9H,WAAW,CAAC6I,oBAAb,CAAH,IAAyCf,GAAG,CAACzC,KAA7C,GAAqD,IAArD,GAA4D,KAAnE;AACH;;AACD7I,OAAO,CAACoB,OAAR,GAAkBA,OAAlB;AACA;;AACA,SAASD,aAAT,CAAuBmL,IAAvB,EAA6BC,IAA7B,EAAmC;AAC/B,QAAMC,UAAU,GAAG,IAAIN,GAAJ,CAAQI,IAAR,CAAnB;;AACA,OAAK,MAAMH,IAAX,IAAmBI,IAAnB,EAAyB;AACrBC,IAAAA,UAAU,CAACC,MAAX,CAAkBN,IAAlB;AACH;;AACD,SAAOK,UAAP;AACH;;AACDxM,OAAO,CAACmB,aAAR,GAAwBA,aAAxB;;AACA,MAAMuL,OAAO,GAAG,CAACjH,MAAD,EAASkH,IAAT,KAAkB7M,MAAM,CAAC4F,SAAP,CAAiBkH,cAAjB,CAAgCjH,IAAhC,CAAqCF,MAArC,EAA6CkH,IAA7C,CAAlC;;AACA,SAASzL,QAAT,CAAkBjB,KAAlB,EAAyB4M,YAAY,GAAG3H,SAAxC,EAAmD;AAC/C,MAAI,CAACpC,QAAQ,CAAC7C,KAAD,CAAb,EAAsB;AAClB,WAAO,KAAP;AACH;;AACD,QAAM6M,IAAI,GAAG7M,KAAK,CAACwH,WAAnB;;AACA,MAAIqF,IAAI,IAAIA,IAAI,CAACpH,SAAjB,EAA4B;AACxB,QAAI,CAAC5C,QAAQ,CAACgK,IAAI,CAACpH,SAAN,CAAb,EAA+B;AAC3B,aAAO,KAAP;AACH,KAHuB,CAIxB;;;AACA,QAAI,CAACgH,OAAO,CAACI,IAAI,CAACpH,SAAN,EAAiB,eAAjB,CAAZ,EAA+C;AAC3C,aAAO,KAAP;AACH;AACJ;;AACD,MAAImH,YAAJ,EAAkB;AACd,UAAM7F,IAAI,GAAGlH,MAAM,CAACkH,IAAP,CAAY/G,KAAZ,CAAb;AACA,WAAOoB,UAAU,CAAC2F,IAAD,EAAO6F,YAAP,CAAjB;AACH;;AACD,SAAO,IAAP;AACH;;AACD7M,OAAO,CAACkB,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,QAAT,CAAkBhB,KAAlB,EAAyB;AACrB,MAAIA,KAAK,IAAI,IAAb,EAAmB;AACf,WAAOA,KAAP;AACH,GAFD,MAGK,IAAIkF,KAAK,CAACC,OAAN,CAAcnF,KAAd,CAAJ,EAA0B;AAC3B,WAAOA,KAAK,CAAC8M,GAAN,CAAUC,IAAI,IAAI/L,QAAQ,CAAC+L,IAAD,CAA1B,CAAP;AACH,GAFI,MAGA,IAAI9L,QAAQ,CAACjB,KAAD,CAAZ,EAAqB;AACtB,UAAMgN,GAAG,GAAG,EAAZ;;AACA,SAAK,MAAMC,GAAX,IAAkBjN,KAAlB,EAAyB;AACrBgN,MAAAA,GAAG,CAACC,GAAD,CAAH,GAAWjM,QAAQ,CAAChB,KAAK,CAACiN,GAAD,CAAN,CAAnB;AACH;;AACD,WAAOD,GAAP;AACH;;AACD,QAAMH,IAAI,GAAG7M,KAAK,CAACwH,WAAnB;;AACA,MAAIqF,IAAJ,EAAU;AACN,YAAQA,IAAI,CAACvH,IAAL,CAAU4H,WAAV,EAAR;AACI,WAAK,MAAL;AACI,eAAO,IAAIL,IAAJ,CAASM,MAAM,CAACnN,KAAD,CAAf,CAAP;;AACJ,WAAK,KAAL;AACI,eAAO,IAAIoN,GAAJ,CAAQpN,KAAR,CAAP;;AACJ,WAAK,KAAL;AACI,eAAO,IAAIiM,GAAJ,CAAQjM,KAAR,CAAP;;AACJ,WAAK,QAAL;AACI,eAAO+D,MAAM,CAACE,IAAP,CAAYjE,KAAZ,CAAP;AARR;AAUH;;AACD,SAAOA,KAAP;AACH;;AACDD,OAAO,CAACiB,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMD,IAAN,CAAW;AACG,MAANiG,MAAM,GAAG;AACT,WAAO,KAAKiB,KAAZ;AACH;;AACsB,OAAlBoF,MAAM,CAACC,WAAW,IAAI;AACvB,WAAO,MAAP;AACH;;AACD9F,EAAAA,WAAW,GAAG;AACV,SAAKS,KAAL,GAAa,CAAb,CADU,CAEV;AACA;AACA;;AACA,SAAKsF,IAAL,GAAY;AACRC,MAAAA,IAAI,EAAE,IADE;AAERC,MAAAA,IAAI,EAAE,IAFE;AAGRzN,MAAAA,KAAK,EAAE;AAHC,KAAZ;AAKA,SAAKuN,IAAL,CAAUC,IAAV,GAAiB,KAAKD,IAAtB;AACA,SAAKA,IAAL,CAAUE,IAAV,GAAiB,KAAKF,IAAtB;AACH;;AACDG,EAAAA,OAAO,GAAG;AACN,WAAOxI,KAAK,CAACjB,IAAN,CAAW,IAAX,CAAP;AACH;;AACDS,EAAAA,QAAQ,GAAG;AACP,WAAQ,YAAW,KAAKgJ,OAAL,GAAe3F,IAAf,CAAoB,OAApB,CAA6B,WAAhD;AACH;;AACgB,IAAfsF,MAAM,CAACM,QAAQ,IAAI;AACjB,SAAK,MAAMC,IAAX,IAAmB,KAAKC,KAAL,EAAnB,EAAiC;AAC7B,YAAMD,IAAI,CAAC5N,KAAX;AACH;AACJ;;AACK,GAAL6N,KAAK,GAAG;AACL,QAAIC,GAAG,GAAG,KAAKP,IAAL,CAAUC,IAApB;;AACA,WAAOM,GAAG,KAAK,KAAKP,IAApB,EAA0B;AACtB;AACA,YAAM;AAAEC,QAAAA;AAAF,UAAWM,GAAjB;AACA,YAAMA,GAAN;AACAA,MAAAA,GAAG,GAAGN,IAAN;AACH;AACJ;AACD;;;AACAO,EAAAA,IAAI,CAAC/N,KAAD,EAAQ;AACR,SAAKiI,KAAL,IAAc,CAAd;AACA,UAAM+F,OAAO,GAAG;AACZR,MAAAA,IAAI,EAAE,KAAKD,IADC;AAEZE,MAAAA,IAAI,EAAE,KAAKF,IAAL,CAAUE,IAFJ;AAGZzN,MAAAA;AAHY,KAAhB;AAKA,SAAKuN,IAAL,CAAUE,IAAV,CAAeD,IAAf,GAAsBQ,OAAtB;AACA,SAAKT,IAAL,CAAUE,IAAV,GAAiBO,OAAjB;AACH;AACD;;;AACAC,EAAAA,QAAQ,CAACC,QAAD,EAAW;AACf,SAAK,MAAMlO,KAAX,IAAoBkO,QAApB,EAA8B;AAC1B,WAAKH,IAAL,CAAU/N,KAAV;AACH;AACJ;AACD;;;AACAmO,EAAAA,OAAO,CAACnO,KAAD,EAAQ;AACX,SAAKiI,KAAL,IAAc,CAAd;AACA,UAAM+F,OAAO,GAAG;AACZR,MAAAA,IAAI,EAAE,KAAKD,IAAL,CAAUC,IADJ;AAEZC,MAAAA,IAAI,EAAE,KAAKF,IAFC;AAGZvN,MAAAA;AAHY,KAAhB;AAKA,SAAKuN,IAAL,CAAUC,IAAV,CAAeC,IAAf,GAAsBO,OAAtB;AACA,SAAKT,IAAL,CAAUC,IAAV,GAAiBQ,OAAjB;AACH;;AACDI,EAAAA,MAAM,CAACR,IAAD,EAAO;AACT,QAAIA,IAAI,KAAK,KAAKL,IAAd,IAAsB,KAAKvG,MAAL,KAAgB,CAA1C,EAA6C;AACzC,aAAO,IAAP;AACH;;AACD,SAAKiB,KAAL,IAAc,CAAd;AACA,UAAMoG,QAAQ,GAAGT,IAAI,CAACH,IAAtB;AACA,UAAMa,QAAQ,GAAGV,IAAI,CAACJ,IAAtB;AACAa,IAAAA,QAAQ,CAACb,IAAT,GAAgBc,QAAhB;AACAA,IAAAA,QAAQ,CAACb,IAAT,GAAgBY,QAAhB;AACA,WAAOT,IAAI,CAAC5N,KAAZ;AACH;AACD;;;AACAuO,EAAAA,KAAK,GAAG;AACJ,WAAO,KAAKH,MAAL,CAAY,KAAKb,IAAL,CAAUC,IAAtB,CAAP;AACH;AACD;;;AACAgB,EAAAA,GAAG,GAAG;AACF,WAAO,KAAKJ,MAAL,CAAY,KAAKb,IAAL,CAAUE,IAAtB,CAAP;AACH;AACD;;;AACAgB,EAAAA,KAAK,CAACC,MAAD,EAAS;AACV,SAAK,MAAMd,IAAX,IAAmB,KAAKC,KAAL,EAAnB,EAAiC;AAC7B,UAAIa,MAAM,CAACd,IAAI,CAAC5N,KAAN,CAAV,EAAwB;AACpB,aAAKoO,MAAL,CAAYR,IAAZ;AACH;AACJ;AACJ;;AACDe,EAAAA,KAAK,GAAG;AACJ,SAAK1G,KAAL,GAAa,CAAb;AACA,SAAKsF,IAAL,CAAUC,IAAV,GAAiB,KAAKD,IAAtB;AACA,SAAKA,IAAL,CAAUE,IAAV,GAAiB,KAAKF,IAAtB;AACH;AACD;;;AACAqB,EAAAA,KAAK,GAAG;AACJ;AACA,WAAO,KAAKrB,IAAL,CAAUC,IAAV,CAAexN,KAAtB;AACH;AACD;;;AACA6O,EAAAA,IAAI,GAAG;AACH;AACA,WAAO,KAAKtB,IAAL,CAAUE,IAAV,CAAezN,KAAtB;AACH;;AA7GM;;AA+GXD,OAAO,CAACgB,IAAR,GAAeA,IAAf;AACA;AACA;AACA;AACA;;AACA,MAAMD,UAAN,CAAiB;AACb0G,EAAAA,WAAW,GAAG;AACV,SAAKsH,OAAL,GAAe,IAAI/N,IAAJ,EAAf;AACA,SAAKgO,eAAL,GAAuB,CAAvB;AACH;;AACS,MAAN/H,MAAM,GAAG;AACT,WAAO,KAAK+H,eAAZ;AACH;AACD;;;AACAC,EAAAA,MAAM,CAAClL,MAAD,EAAS;AACX,SAAKgL,OAAL,CAAaf,IAAb,CAAkBjK,MAAlB;AACA,SAAKiL,eAAL,IAAwBjL,MAAM,CAACkD,MAA/B;AACH;AACD;AACJ;AACA;AACA;;;AACIiI,EAAAA,QAAQ,GAAG;AACP,QAAI,KAAKF,eAAL,GAAuB,CAA3B,EAA8B;AAC1B,aAAO,IAAP;AACH;;AACD,UAAMG,WAAW,GAAG,KAAKJ,OAAL,CAAaF,KAAb,EAApB;;AACA,QAAIM,WAAW,IAAI,IAAf,IAAuBA,WAAW,CAAC/K,UAAZ,IAA0B,CAArD,EAAwD;AACpD,aAAO+K,WAAW,CAACC,WAAZ,CAAwB,CAAxB,CAAP;AACH,KAPM,CAQP;AACA;;;AACA,UAAMC,SAAS,GAAG,KAAKC,IAAL,CAAU,CAAV,CAAlB;AACA,UAAMrP,KAAK,GAAGoP,SAAS,CAACD,WAAV,CAAsB,CAAtB,CAAd,CAXO,CAYP;;AACA,SAAKJ,eAAL,IAAwB,CAAxB;AACA,SAAKD,OAAL,CAAaX,OAAb,CAAqBiB,SAArB;AACA,WAAOpP,KAAP;AACH;AACD;;;AACAqP,EAAAA,IAAI,CAACC,IAAD,EAAO;AACP,QAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,GAAG,CAAvC,EAA0C;AACtC,YAAM,IAAI9L,OAAO,CAACoB,yBAAZ,CAAsC,+CAAtC,CAAN;AACH,KAHM,CAIP;;;AACA,QAAI0K,IAAI,GAAG,KAAKP,eAAhB,EAAiC;AAC7B,aAAOhL,MAAM,CAACwL,KAAP,CAAa,CAAb,CAAP;AACH,KAPM,CAQP;AACA;;;AACA,UAAMjH,MAAM,GAAGvE,MAAM,CAACyL,WAAP,CAAmBF,IAAnB,CAAf;;AACA,SAAK,IAAIG,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGH,IAApC,GAA2C;AACvC,YAAMxL,MAAM,GAAG,KAAKgL,OAAL,CAAaP,KAAb,EAAf;;AACA,UAAIzK,MAAM,IAAI,IAAd,EAAoB;AAChB;AACH;;AACD,YAAM4L,cAAc,GAAGJ,IAAI,GAAGG,SAA9B;AACA,YAAME,aAAa,GAAG1E,IAAI,CAAC2E,GAAL,CAASF,cAAT,EAAyB5L,MAAM,CAACK,UAAhC,CAAtB;AACA,YAAM0L,KAAK,GAAG/L,MAAM,CAACgH,QAAP,CAAgB,CAAhB,EAAmB6E,aAAnB,CAAd;AACArH,MAAAA,MAAM,CAACyD,GAAP,CAAW8D,KAAX,EAAkBJ,SAAlB;AACAA,MAAAA,SAAS,IAAIE,aAAb;AACA,WAAKZ,eAAL,IAAwBY,aAAxB;;AACA,UAAIA,aAAa,GAAG7L,MAAM,CAACK,UAA3B,EAAuC;AACnC,aAAK2K,OAAL,CAAaX,OAAb,CAAqBrK,MAAM,CAACgH,QAAP,CAAgB6E,aAAhB,CAArB;AACH;AACJ;;AACD,WAAOrH,MAAP;AACH;;AA9DY;;AAgEjBvI,OAAO,CAACe,UAAR,GAAqBA,UAArB;AACA;;AACA,MAAMD,WAAN,CAAkB;AACd2G,EAAAA,WAAW,CAACsI,UAAD,EAAa;AACpB,SAAKC,IAAL,GAAY9K,SAAZ;AACA,SAAK+K,IAAL,GAAY/K,SAAZ;AACA,SAAKgL,UAAL,GAAkBhL,SAAlB;AACA,SAAKiL,MAAL,GAAc,KAAd;AACA,UAAMC,WAAW,GAAGL,UAAU,CAAChI,KAAX,CAAiB,GAAjB,EAAsBC,IAAtB,CAA2B,KAA3B,CAApB,CALoB,CAKmC;;AACvD,QAAIoI,WAAW,CAACC,QAAZ,CAAqB,OAArB,CAAJ,EAAmC;AAC/B;AACA,WAAKH,UAAL,GAAkBI,kBAAkB,CAACF,WAAD,CAApC;AACA;AACH;;AACD,UAAMG,SAAS,GAAI,aAAYH,WAAY,EAA3C;AACA,QAAII,GAAJ;;AACA,QAAI;AACAA,MAAAA,GAAG,GAAG,IAAInN,KAAK,CAACoN,GAAV,CAAcF,SAAd,CAAN;AACH,KAFD,CAGA,OAAOG,QAAP,EAAiB;AACb,YAAMC,YAAY,GAAG,IAAIlN,OAAO,CAACoE,iBAAZ,CAA+B,mBAAkBuI,WAAY,WAA7D,CAArB;AACAO,MAAAA,YAAY,CAACC,KAAb,GAAqBF,QAArB;AACA,YAAMC,YAAN;AACH;;AACD,UAAME,QAAQ,GAAGL,GAAG,CAACK,QAArB;AACA,UAAMZ,IAAI,GAAGO,GAAG,CAACP,IAAjB;AACA,QAAIa,UAAU,GAAGR,kBAAkB,CAACO,QAAD,CAAlB,CAA6B1D,WAA7B,EAAjB;;AACA,QAAI2D,UAAU,CAACC,UAAX,CAAsB,GAAtB,KAA8BD,UAAU,CAACT,QAAX,CAAoB,GAApB,CAAlC,EAA4D;AACxD,WAAKF,MAAL,GAAc,IAAd;AACAW,MAAAA,UAAU,GAAGA,UAAU,CAACE,SAAX,CAAqB,CAArB,EAAwBH,QAAQ,CAAC5J,MAAT,GAAkB,CAA1C,CAAb;AACH;;AACD,SAAK+I,IAAL,GAAYc,UAAU,CAAC3D,WAAX,EAAZ;;AACA,QAAI,OAAO8C,IAAP,KAAgB,QAApB,EAA8B;AAC1B,WAAKA,IAAL,GAAYA,IAAZ;AACH,KAFD,MAGK,IAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,EAAzC,EAA6C;AAC9C,WAAKA,IAAL,GAAY7C,MAAM,CAAC6D,QAAP,CAAgBhB,IAAhB,EAAsB,EAAtB,CAAZ;AACH,KAFI,MAGA;AACD,WAAKA,IAAL,GAAY,KAAZ;AACH;;AACD,QAAI,KAAKA,IAAL,KAAc,CAAlB,EAAqB;AACjB,YAAM,IAAIxM,OAAO,CAACyN,eAAZ,CAA4B,mCAA5B,CAAN;AACH;;AACDpR,IAAAA,MAAM,CAACqR,MAAP,CAAc,IAAd;AACH;;AACwC,GAAxC7D,MAAM,CAAC8D,GAAP,CAAW,4BAAX,CAAwC,IAAI;AACzC,WAAO,KAAKC,OAAL,EAAP;AACH;;AACDA,EAAAA,OAAO,GAAG;AACN,WAAQ,oBAAmB,KAAK1M,QAAL,EAAgB,IAA3C;AACH;;AACDA,EAAAA,QAAQ,GAAG;AACP,QAAI,OAAO,KAAKqL,IAAZ,KAAqB,QAAzB,EAAmC;AAC/B,UAAI,KAAKG,MAAT,EAAiB;AACb,eAAQ,IAAG,KAAKH,IAAK,KAAI,KAAKC,IAAK,EAAnC;AACH;;AACD,aAAQ,GAAE,KAAKD,IAAK,IAAG,KAAKC,IAAK,EAAjC;AACH;;AACD,WAAQ,GAAE,KAAKC,UAAW,EAA1B;AACH;;AACgB,SAAV1I,UAAU,CAACrB,CAAD,EAAI;AACjB,WAAO,IAAIrF,WAAJ,CAAgBqF,CAAhB,CAAP;AACH;;AACkB,SAAZmL,YAAY,CAACtB,IAAD,EAAOC,IAAP,EAAa;AAC5B,QAAID,IAAI,CAAC/J,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACpB+J,MAAAA,IAAI,GAAI,IAAGA,IAAK,GAAhB,CADoB,CACA;AACvB;;AACD,WAAOlP,WAAW,CAAC0G,UAAZ,CAAwB,GAAEwI,IAAK,IAAGC,IAAK,EAAvC,CAAP;AACH;;AACmB,SAAbsB,aAAa,CAAC;AAAEhM,IAAAA,IAAF;AAAQ0K,IAAAA;AAAR,GAAD,EAAiB;AACjC,WAAOnP,WAAW,CAACwQ,YAAZ,CAAyB/L,IAAzB,EAA+B0K,IAA/B,CAAP;AACH;;AAtEa;;AAwElBjQ,OAAO,CAACc,WAAR,GAAsBA,WAAtB;AACAd,OAAO,CAACa,kBAAR,GAA6B;AACzB;AACA2Q,EAAAA,QAAQ,GAAG;AACP,WAAO,IAAIlO,MAAM,CAACmO,QAAX,EAAP;AACH;;AAJwB,CAA7B;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAzR,OAAO,CAACY,oBAAR,GAA+B,gBAA/B;AACA;;AACA,SAASD,WAAT,CAAqBgJ,OAArB,EAA8B;AAC1B,SAAOW,OAAO,CAAC3J,WAAR,CAAoBgJ,OAApB,EAA6B;AAAE+H,IAAAA,IAAI,EAAE1R,OAAO,CAACY;AAAhB,GAA7B,CAAP;AACH;;AACDZ,OAAO,CAACW,WAAR,GAAsBA,WAAtB;AACA,MAAMgR,eAAe,GAAG,IAAIzF,GAAJ,EAAxB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASxL,eAAT,CAAyBiJ,OAAzB,EAAkC;AAC9B,MAAI,CAACgI,eAAe,CAACvF,GAAhB,CAAoBzC,OAApB,CAAL,EAAmC;AAC/BgI,IAAAA,eAAe,CAACC,GAAhB,CAAoBjI,OAApB;AACA,WAAOhJ,WAAW,CAACgJ,OAAD,CAAlB;AACH;AACJ;;AACD3J,OAAO,CAACU,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;;AACA,SAASD,YAAT,CAAsBoR,EAAtB,EAA0B;AACtB,SAAO/R,MAAM,CAACgS,MAAP,CAAcD,EAAd,EAAkB7J,IAAlB,CAAuB,IAAvB,CAAP;AACH;;AACDhI,OAAO,CAACS,YAAR,GAAuBA,YAAvB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,uBAAT,CAAiCuR,MAAjC,EAAyC;AACrC,MAAI,CAACA,MAAL,EAAa;AACT,WAAO,KAAP;AACH;;AACD,MAAIA,MAAM,CAACpJ,YAAX,EAAyB;AACrB;AACA,WAAO,IAAP;AACH;;AACD,MAAIoJ,MAAM,CAAChJ,WAAP,CAAmBiJ,4BAAnB,IAAmD,IAAvD,EAA6D;AACzD;AACA,QAAID,MAAM,CAAChJ,WAAP,CAAmB2B,IAAnB,KAA4B9G,QAAQ,CAACqO,UAAT,CAAoBC,UAApD,EAAgE;AAC5D;AACA,aAAO,IAAP;AACH;AACJ;;AACD,SAAO,KAAP;AACH;;AACDlS,OAAO,CAACQ,uBAAR,GAAkCA,uBAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,OAAT,CAAiB4R,QAAjB,EAA2BC,KAAK,GAAG,CAAnC,EAAsC;AAClC,QAAMC,KAAK,GAAGlN,KAAK,CAACjB,IAAN,CAAWiO,QAAX,CAAd,CADkC,CACE;;AACpC,MAAIC,KAAK,GAAGC,KAAK,CAACpL,MAAlB,EAA0B;AACtB,UAAM,IAAIxD,OAAO,CAACoE,iBAAZ,CAA8B,6CAA9B,CAAN;AACH;;AACD,MAAIyK,uBAAuB,GAAGD,KAAK,CAACpL,MAApC;AACA,QAAMsL,UAAU,GAAGH,KAAK,GAAGC,KAAK,CAACpL,MAAd,KAAyB,CAAzB,GAA6B,CAA7B,GAAiCoL,KAAK,CAACpL,MAAN,GAAemL,KAAnE;;AACA,SAAOE,uBAAuB,GAAGC,UAAjC,EAA6C;AACzC;AACA,UAAMC,WAAW,GAAGtH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACuH,MAAL,KAAgBH,uBAA3B,CAApB;AACAA,IAAAA,uBAAuB,IAAI,CAA3B,CAHyC,CAIzC;;AACA,UAAMI,QAAQ,GAAGL,KAAK,CAACC,uBAAD,CAAtB;AACAD,IAAAA,KAAK,CAACC,uBAAD,CAAL,GAAiCD,KAAK,CAACG,WAAD,CAAtC;AACAH,IAAAA,KAAK,CAACG,WAAD,CAAL,GAAqBE,QAArB;AACH;;AACD,SAAON,KAAK,GAAGC,KAAK,CAACpL,MAAd,KAAyB,CAAzB,GAA6BoL,KAA7B,GAAqCA,KAAK,CAACM,KAAN,CAAYJ,UAAZ,CAA5C;AACH;;AACDvS,OAAO,CAACO,OAAR,GAAkBA,OAAlB,C,CACA;AACA;;AACA,SAASD,0BAAT,CAAoCgG,OAApC,EAA6CP,OAA7C,EAAsD;AAClD,MAAIO,OAAO,CAACsM,SAAR,IAAqBtM,OAAO,CAAC4B,KAA7B,IAAsC5B,OAAO,CAACuM,QAA9C,IAA0DvM,OAAO,CAACwM,IAAlE,IAA0ExM,OAAO,CAACyM,OAAtF,EAA+F;AAC3F,WAAO,IAAP;AACH;;AACD,MAAIzM,OAAO,CAAC0M,SAAR,IACAjN,OADA,IAEAA,OAAO,CAACkN,GAFR,KAGClN,OAAO,CAACkN,GAAR,CAAYC,MAAZ,KAAuB,CAAvB,IAA4BnN,OAAO,CAACkN,GAAR,KAAgB,QAH7C,CAAJ,EAG4D;AACxD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACDjT,OAAO,CAACM,0BAAR,GAAqCA,0BAArC;AACA;;AACA,SAASD,0BAAT,GAAsC;AAClC,MAAI8S,uBAAuB,GAAG,IAA9B,CADkC,CAElC;AACA;;AACA,MAAI,OAAO7I,OAAO,CAAC8I,GAAR,CAAYC,kCAAnB,KAA0D,QAA1D,IACA/I,OAAO,CAAC8I,GAAR,CAAYC,kCAAZ,CAA+CpM,MAA/C,GAAwD,CAD5D,EAC+D;AAC3D,QAAI;AACA;AACA;AACA;AACAkM,MAAAA,uBAAuB,GAAGhQ,OAAO,CAACmH,OAAO,CAAC8I,GAAR,CAAYC,kCAAb,CAAjC;AACH,KALD,CAMA,MAAM,CACF;AACH;AACJ,GAXD,MAYK;AACD,QAAI;AACA;AACA;AACA;AACAF,MAAAA,uBAAuB,GAAGhQ,OAAO,CAAC,2BAAD,CAAjC;AACH,KALD,CAMA,MAAM,CACF;AACH;AACJ;;AACD,SAAOgQ,uBAAP;AACH;;AACDnT,OAAO,CAACK,0BAAR,GAAqCA,0BAArC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,eAAT,CAAyBkT,IAAzB,EAA+BC,IAA/B,EAAqC;AACjC,MAAID,IAAI,IAAI,IAAR,IAAgBC,IAAI,IAAI,IAA5B,EAAkC;AAC9B,WAAO,CAAP;AACH;;AACD,MAAID,IAAI,IAAI,IAAZ,EAAkB;AACd,WAAO,CAAC,CAAR;AACH;;AACD,MAAIC,IAAI,IAAI,IAAZ,EAAkB;AACd,WAAO,CAAP;AACH;;AACD,SAAOvT,OAAO,CAACiD,SAAR,CAAkBuB,OAAlB,CAA0B8O,IAAI,CAACE,EAA/B,EAAmCD,IAAI,CAACC,EAAxC,CAAP;AACH;;AACDxT,OAAO,CAACI,eAAR,GAA0BA,eAA1B;;AACA,SAASD,YAAT,CAAsBF,KAAtB,EAA6B;AACzB,MAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,OAAOiL,IAAI,CAACuI,KAAL,CAAWxT,KAAX,CAAP;AACJ,QAAMyT,WAAW,GAAGtG,MAAM,CAAC6D,QAAP,CAAgB0C,MAAM,CAAC1T,KAAD,CAAtB,EAA+B,EAA/B,CAApB;AACA,SAAOmN,MAAM,CAACwG,KAAP,CAAaF,WAAb,IAA4B,IAA5B,GAAmCA,WAA1C;AACH;;AACD1T,OAAO,CAACG,YAAR,GAAuBA,YAAvB;;AACA,SAASD,oBAAT,CAA8BD,KAA9B,EAAqC;AACjC,QAAM4T,SAAS,GAAG1T,YAAY,CAACF,KAAD,CAA9B;AACA,SAAO4T,SAAS,IAAI,IAAb,IAAqBA,SAAS,IAAI,CAAlC,GAAsCA,SAAtC,GAAkD,IAAzD;AACH;;AACD7T,OAAO,CAACE,oBAAR,GAA+BA,oBAA/B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.ByteUtils = void 0;\nconst crypto = require(\"crypto\");\nconst os = require(\"os\");\nconst url_1 = require(\"url\");\nconst bson_1 = require(\"./bson\");\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\nconst constants_2 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst write_concern_1 = require(\"./write_concern\");\nexports.ByteUtils = {\n    toLocalBufferType(buffer) {\n        return Buffer.isBuffer(buffer)\n            ? buffer\n            : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    },\n    equals(seqA, seqB) {\n        return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);\n    },\n    compare(seqA, seqB) {\n        return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);\n    },\n    toBase64(uint8array) {\n        return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');\n    }\n};\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nfunction checkCollectionName(collectionName) {\n    if ('string' !== typeof collectionName) {\n        throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n    }\n    if (!collectionName || collectionName.indexOf('..') !== -1) {\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n    }\n    if (collectionName.indexOf('$') !== -1 &&\n        collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n    }\n    if (collectionName.match(/^\\.|\\.$/) != null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n    }\n    // Validate that we are not passing 0x00 in the collection name\n    if (collectionName.indexOf('\\x00') !== -1) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n    }\n}\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nfunction normalizeHintField(hint) {\n    let finalHint = undefined;\n    if (typeof hint === 'string') {\n        finalHint = hint;\n    }\n    else if (Array.isArray(hint)) {\n        finalHint = {};\n        hint.forEach(param => {\n            finalHint[param] = 1;\n        });\n    }\n    else if (hint != null && typeof hint === 'object') {\n        finalHint = {};\n        for (const name in hint) {\n            finalHint[name] = hint[name];\n        }\n    }\n    return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\nconst TO_STRING = (object) => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\nfunction isObject(arg) {\n    return '[object Object]' === TO_STRING(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction mergeOptions(target, source) {\n    return { ...target, ...source };\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n    const filterOptions = {};\n    for (const name in options) {\n        if (names.includes(name)) {\n            filterOptions[name] = options[name];\n        }\n    }\n    // Filtered options\n    return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n    if (db && db.s.options?.retryWrites) {\n        target.retryWrites = true;\n    }\n    return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The resolution type of the possible promise\n * @param value - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nfunction isPromiseLike(value) {\n    return !!value && typeof value.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n    const capabilities = getTopology(target).capabilities;\n    if (options.collation && typeof options.collation === 'object') {\n        if (capabilities && capabilities.commandsTakeCollation) {\n            command.collation = options.collation;\n        }\n        else {\n            throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n        }\n    }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n    if (options && options.session && options.session.inTransaction()) {\n        return;\n    }\n    const readConcern = Object.assign({}, command.readConcern || {});\n    if (coll.s.readConcern) {\n        Object.assign(readConcern, coll.s.readConcern);\n    }\n    if (Object.keys(readConcern).length > 0) {\n        Object.assign(command, { readConcern: readConcern });\n    }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nfunction decorateWithExplain(command, explain) {\n    if (command.explain) {\n        return command;\n    }\n    return { explain: command, verbosity: explain.verbosity };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\nfunction getTopology(provider) {\n    // MongoClient or ClientSession or AbstractCursor\n    if ('topology' in provider && provider.topology) {\n        return provider.topology;\n    }\n    else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n        return provider.s.client.topology;\n    }\n    else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n        return provider.s.db.s.client.topology;\n    }\n    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/** @internal */\nfunction ns(ns) {\n    return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nclass MongoDBNamespace {\n    /**\n     * Create a namespace object\n     *\n     * @param db - database name\n     * @param collection - collection name\n     */\n    constructor(db, collection) {\n        this.db = db;\n        this.collection = collection === '' ? undefined : collection;\n    }\n    toString() {\n        return this.collection ? `${this.db}.${this.collection}` : this.db;\n    }\n    withCollection(collection) {\n        return new MongoDBNamespace(this.db, collection);\n    }\n    static fromString(namespace) {\n        if (typeof namespace !== 'string' || namespace === '') {\n            // TODO(NODE-3483): Replace with MongoNamespaceError\n            throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n        }\n        const [db, ...collectionParts] = namespace.split('.');\n        const collection = collectionParts.join('.');\n        return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n    }\n}\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\nfunction* makeCounter(seed = 0) {\n    let count = seed;\n    while (true) {\n        const newCount = count;\n        count += 1;\n        yield newCount;\n    }\n}\nexports.makeCounter = makeCounter;\nfunction maybeCallback(promiseFn, callback) {\n    const promise = promiseFn();\n    if (callback == null) {\n        return promise;\n    }\n    promise.then(result => callback(undefined, result), error => callback(error));\n    return;\n}\nexports.maybeCallback = maybeCallback;\n/** @internal */\nfunction databaseNamespace(ns) {\n    return ns.split('.')[0];\n}\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nfunction uuidV4() {\n    const result = crypto.randomBytes(16);\n    result[6] = (result[6] & 0x0f) | 0x40;\n    result[8] = (result[8] & 0x3f) | 0x80;\n    return result;\n}\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nfunction maxWireVersion(topologyOrServer) {\n    if (topologyOrServer) {\n        if (topologyOrServer.loadBalanced) {\n            // Since we do not have a monitor, we assume the load balanced server is always\n            // pointed at the latest mongodb version. There is a risk that for on-prem\n            // deployments that don't upgrade immediately that this could alert to the\n            // application that a feature is available that is actually not.\n            return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n        }\n        if (topologyOrServer.hello) {\n            return topologyOrServer.hello.maxWireVersion;\n        }\n        if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n            const lastHello = topologyOrServer.lastHello();\n            if (lastHello) {\n                return lastHello.maxWireVersion;\n            }\n        }\n        if (topologyOrServer.description &&\n            'maxWireVersion' in topologyOrServer.description &&\n            topologyOrServer.description.maxWireVersion != null) {\n            return topologyOrServer.description.maxWireVersion;\n        }\n    }\n    return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = 0;\n    for (idx = 0; idx < arr.length; ++idx) {\n        awaiting++;\n        eachFn(arr[idx], eachCallback);\n    }\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n        }\n    }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n    if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n        return false;\n    }\n    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n    if (lhs === rhs) {\n        return true;\n    }\n    if (!lhs || !rhs) {\n        return lhs === rhs;\n    }\n    if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n        return false;\n    }\n    if (lhs.constructor.name !== rhs.constructor.name) {\n        return false;\n    }\n    if (lhs.message !== rhs.message) {\n        return false;\n    }\n    return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n    return function stateTransition(target, newState) {\n        const legalStates = stateTable[target.s.state];\n        if (legalStates && legalStates.indexOf(newState) < 0) {\n            throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n        }\n        target.emit('stateChanged', target.s.state, newState);\n        target.s.state = newState;\n    };\n}\nexports.makeStateMachine = makeStateMachine;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\nfunction makeClientMetadata(options) {\n    const name = options.driverInfo.name ? `nodejs|${options.driverInfo.name}` : 'nodejs';\n    const version = options.driverInfo.version\n        ? `${NODE_DRIVER_VERSION}|${options.driverInfo.version}`\n        : NODE_DRIVER_VERSION;\n    const platform = options.driverInfo.platform\n        ? `Node.js ${process.version}, ${os.endianness()}|${options.driverInfo.platform}`\n        : `Node.js ${process.version}, ${os.endianness()}`;\n    const metadata = {\n        driver: {\n            name,\n            version\n        },\n        os: {\n            type: os.type(),\n            name: process.platform,\n            architecture: process.arch,\n            version: os.release()\n        },\n        platform\n    };\n    if (options.appName) {\n        // MongoDB requires the appName not exceed a byte length of 128\n        const name = Buffer.byteLength(options.appName, 'utf8') <= 128\n            ? options.appName\n            : Buffer.from(options.appName, 'utf8').subarray(0, 128).toString('utf8');\n        metadata.application = { name };\n    }\n    return metadata;\n}\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\nfunction now() {\n    const hrtime = process.hrtime();\n    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n    if (typeof started !== 'number') {\n        throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n    }\n    const elapsed = now() - started;\n    return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n    if (Array.isArray(doc)) {\n        for (const document of doc) {\n            if (hasAtomicOperators(document)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    const keys = Object.keys(doc);\n    return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nfunction resolveOptions(parent, options) {\n    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));\n    // Users cannot pass a readConcern/writeConcern to operations in a transaction\n    const session = options?.session;\n    if (!session?.inTransaction()) {\n        const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;\n        if (readConcern) {\n            result.readConcern = readConcern;\n        }\n        const writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n        if (writeConcern) {\n            result.writeConcern = writeConcern;\n        }\n    }\n    const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;\n    if (readPreference) {\n        result.readPreference = readPreference;\n    }\n    return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n    set = Array.isArray(set) ? new Set(set) : set;\n    subset = Array.isArray(subset) ? new Set(subset) : subset;\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\nfunction isHello(doc) {\n    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\nfunction setDifference(setA, setB) {\n    const difference = new Set(setA);\n    for (const elem of setB) {\n        difference.delete(elem);\n    }\n    return difference;\n}\nexports.setDifference = setDifference;\nconst HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\nfunction isRecord(value, requiredKeys = undefined) {\n    if (!isObject(value)) {\n        return false;\n    }\n    const ctor = value.constructor;\n    if (ctor && ctor.prototype) {\n        if (!isObject(ctor.prototype)) {\n            return false;\n        }\n        // Check to see if some method exists from the Object exists\n        if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n            return false;\n        }\n    }\n    if (requiredKeys) {\n        const keys = Object.keys(value);\n        return isSuperset(keys, requiredKeys);\n    }\n    return true;\n}\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n    if (value == null) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        return value.map(item => deepCopy(item));\n    }\n    else if (isRecord(value)) {\n        const res = {};\n        for (const key in value) {\n            res[key] = deepCopy(value[key]);\n        }\n        return res;\n    }\n    const ctor = value.constructor;\n    if (ctor) {\n        switch (ctor.name.toLowerCase()) {\n            case 'date':\n                return new ctor(Number(value));\n            case 'map':\n                return new Map(value);\n            case 'set':\n                return new Set(value);\n            case 'buffer':\n                return Buffer.from(value);\n        }\n    }\n    return value;\n}\nexports.deepCopy = deepCopy;\n/**\n * A sequential list of items in a circularly linked list\n * @remarks\n * The head node is special, it is always defined and has a value of null.\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\n * @internal\n */\nclass List {\n    get length() {\n        return this.count;\n    }\n    get [Symbol.toStringTag]() {\n        return 'List';\n    }\n    constructor() {\n        this.count = 0;\n        // this is carefully crafted:\n        // declaring a complete and consistently key ordered\n        // object is beneficial to the runtime optimizations\n        this.head = {\n            next: null,\n            prev: null,\n            value: null\n        };\n        this.head.next = this.head;\n        this.head.prev = this.head;\n    }\n    toArray() {\n        return Array.from(this);\n    }\n    toString() {\n        return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\n    }\n    *[Symbol.iterator]() {\n        for (const node of this.nodes()) {\n            yield node.value;\n        }\n    }\n    *nodes() {\n        let ptr = this.head.next;\n        while (ptr !== this.head) {\n            // Save next before yielding so that we make removing within iteration safe\n            const { next } = ptr;\n            yield ptr;\n            ptr = next;\n        }\n    }\n    /** Insert at end of list */\n    push(value) {\n        this.count += 1;\n        const newNode = {\n            next: this.head,\n            prev: this.head.prev,\n            value\n        };\n        this.head.prev.next = newNode;\n        this.head.prev = newNode;\n    }\n    /** Inserts every item inside an iterable instead of the iterable itself */\n    pushMany(iterable) {\n        for (const value of iterable) {\n            this.push(value);\n        }\n    }\n    /** Insert at front of list */\n    unshift(value) {\n        this.count += 1;\n        const newNode = {\n            next: this.head.next,\n            prev: this.head,\n            value\n        };\n        this.head.next.prev = newNode;\n        this.head.next = newNode;\n    }\n    remove(node) {\n        if (node === this.head || this.length === 0) {\n            return null;\n        }\n        this.count -= 1;\n        const prevNode = node.prev;\n        const nextNode = node.next;\n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n        return node.value;\n    }\n    /** Removes the first node at the front of the list */\n    shift() {\n        return this.remove(this.head.next);\n    }\n    /** Removes the last node at the end of the list */\n    pop() {\n        return this.remove(this.head.prev);\n    }\n    /** Iterates through the list and removes nodes where filter returns true */\n    prune(filter) {\n        for (const node of this.nodes()) {\n            if (filter(node.value)) {\n                this.remove(node);\n            }\n        }\n    }\n    clear() {\n        this.count = 0;\n        this.head.next = this.head;\n        this.head.prev = this.head;\n    }\n    /** Returns the first item in the list, does not remove */\n    first() {\n        // If the list is empty, value will be the head's null\n        return this.head.next.value;\n    }\n    /** Returns the last item in the list, does not remove */\n    last() {\n        // If the list is empty, value will be the head's null\n        return this.head.prev.value;\n    }\n}\nexports.List = List;\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nclass BufferPool {\n    constructor() {\n        this.buffers = new List();\n        this.totalByteLength = 0;\n    }\n    get length() {\n        return this.totalByteLength;\n    }\n    /** Adds a buffer to the internal buffer pool list */\n    append(buffer) {\n        this.buffers.push(buffer);\n        this.totalByteLength += buffer.length;\n    }\n    /**\n     * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\n     * otherwise return null. Size can be negative, caller should error check.\n     */\n    getInt32() {\n        if (this.totalByteLength < 4) {\n            return null;\n        }\n        const firstBuffer = this.buffers.first();\n        if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n            return firstBuffer.readInt32LE(0);\n        }\n        // Unlikely case: an int32 is split across buffers.\n        // Use read and put the returned buffer back on top\n        const top4Bytes = this.read(4);\n        const value = top4Bytes.readInt32LE(0);\n        // Put it back.\n        this.totalByteLength += 4;\n        this.buffers.unshift(top4Bytes);\n        return value;\n    }\n    /** Reads the requested number of bytes, optionally consuming them */\n    read(size) {\n        if (typeof size !== 'number' || size < 0) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n        }\n        // oversized request returns empty buffer\n        if (size > this.totalByteLength) {\n            return Buffer.alloc(0);\n        }\n        // We know we have enough, we just don't know how it is spread across chunks\n        // TODO(NODE-4732): alloc API should change based on raw option\n        const result = Buffer.allocUnsafe(size);\n        for (let bytesRead = 0; bytesRead < size;) {\n            const buffer = this.buffers.shift();\n            if (buffer == null) {\n                break;\n            }\n            const bytesRemaining = size - bytesRead;\n            const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n            const bytes = buffer.subarray(0, bytesReadable);\n            result.set(bytes, bytesRead);\n            bytesRead += bytesReadable;\n            this.totalByteLength -= bytesReadable;\n            if (bytesReadable < buffer.byteLength) {\n                this.buffers.unshift(buffer.subarray(bytesReadable));\n            }\n        }\n        return result;\n    }\n}\nexports.BufferPool = BufferPool;\n/** @public */\nclass HostAddress {\n    constructor(hostString) {\n        this.host = undefined;\n        this.port = undefined;\n        this.socketPath = undefined;\n        this.isIPv6 = false;\n        const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n        if (escapedHost.endsWith('.sock')) {\n            // heuristically determine if we're working with a domain socket\n            this.socketPath = decodeURIComponent(escapedHost);\n            return;\n        }\n        const urlString = `iLoveJS://${escapedHost}`;\n        let url;\n        try {\n            url = new url_1.URL(urlString);\n        }\n        catch (urlError) {\n            const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\n            runtimeError.cause = urlError;\n            throw runtimeError;\n        }\n        const hostname = url.hostname;\n        const port = url.port;\n        let normalized = decodeURIComponent(hostname).toLowerCase();\n        if (normalized.startsWith('[') && normalized.endsWith(']')) {\n            this.isIPv6 = true;\n            normalized = normalized.substring(1, hostname.length - 1);\n        }\n        this.host = normalized.toLowerCase();\n        if (typeof port === 'number') {\n            this.port = port;\n        }\n        else if (typeof port === 'string' && port !== '') {\n            this.port = Number.parseInt(port, 10);\n        }\n        else {\n            this.port = 27017;\n        }\n        if (this.port === 0) {\n            throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n        }\n        Object.freeze(this);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new HostAddress('${this.toString()}')`;\n    }\n    toString() {\n        if (typeof this.host === 'string') {\n            if (this.isIPv6) {\n                return `[${this.host}]:${this.port}`;\n            }\n            return `${this.host}:${this.port}`;\n        }\n        return `${this.socketPath}`;\n    }\n    static fromString(s) {\n        return new HostAddress(s);\n    }\n    static fromHostPort(host, port) {\n        if (host.includes(':')) {\n            host = `[${host}]`; // IPv6 address\n        }\n        return HostAddress.fromString(`${host}:${port}`);\n    }\n    static fromSrvRecord({ name, port }) {\n        return HostAddress.fromHostPort(name, port);\n    }\n}\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n    // We prefer not to rely on ObjectId having a createPk method\n    createPk() {\n        return new bson_1.ObjectId();\n    }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```ts\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });\n}\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nfunction emitWarningOnce(message) {\n    if (!emittedWarnings.has(message)) {\n        emittedWarnings.add(message);\n        return emitWarning(message);\n    }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nfunction enumToString(en) {\n    return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nfunction supportsRetryableWrites(server) {\n    if (!server) {\n        return false;\n    }\n    if (server.loadBalanced) {\n        // Loadbalanced topologies will always support retry writes\n        return true;\n    }\n    if (server.description.logicalSessionTimeoutMinutes != null) {\n        // that supports sessions\n        if (server.description.type !== common_1.ServerType.Standalone) {\n            // and that is not a standalone\n            return true;\n        }\n    }\n    return false;\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\n/**\n * Fisherâ€“Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\nfunction shuffle(sequence, limit = 0) {\n    const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n    if (limit > items.length) {\n        throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n    }\n    let remainingItemsToShuffle = items.length;\n    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n    while (remainingItemsToShuffle > lowerBound) {\n        // Pick a remaining element\n        const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n        remainingItemsToShuffle -= 1;\n        // And swap it with the current element\n        const swapHold = items[remainingItemsToShuffle];\n        items[remainingItemsToShuffle] = items[randomIndex];\n        items[randomIndex] = swapHold;\n    }\n    return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\nexports.shuffle = shuffle;\n// TODO(NODE-4936): read concern eligibility for commands should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n        return true;\n    }\n    if (command.mapReduce &&\n        options &&\n        options.out &&\n        (options.out.inline === 1 || options.out === 'inline')) {\n        return true;\n    }\n    return false;\n}\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\nfunction getMongoDBClientEncryption() {\n    let mongodbClientEncryption = null;\n    // NOTE(NODE-4254): This is to get around the circular dependency between\n    // mongodb-client-encryption and the driver in the test scenarios.\n    if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' &&\n        process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n        try {\n            // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n            // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n            // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n            mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n        }\n        catch {\n            // ignore\n        }\n    }\n    else {\n        try {\n            // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n            // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n            // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n            mongodbClientEncryption = require('mongodb-client-encryption');\n        }\n        catch {\n            // ignore\n        }\n    }\n    return mongodbClientEncryption;\n}\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;\n/**\n * Compare objectIds. `null` is always less\n * - `+1 = oid1 is greater than oid2`\n * - `-1 = oid1 is less than oid2`\n * - `+0 = oid1 is equal oid2`\n */\nfunction compareObjectId(oid1, oid2) {\n    if (oid1 == null && oid2 == null) {\n        return 0;\n    }\n    if (oid1 == null) {\n        return -1;\n    }\n    if (oid2 == null) {\n        return 1;\n    }\n    return exports.ByteUtils.compare(oid1.id, oid2.id);\n}\nexports.compareObjectId = compareObjectId;\nfunction parseInteger(value) {\n    if (typeof value === 'number')\n        return Math.trunc(value);\n    const parsedValue = Number.parseInt(String(value), 10);\n    return Number.isNaN(parsedValue) ? null : parsedValue;\n}\nexports.parseInteger = parseInteger;\nfunction parseUnsignedInteger(value) {\n    const parsedInt = parseInteger(value);\n    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\nexports.parseUnsignedInteger = parseUnsignedInteger;\n"]},"metadata":{},"sourceType":"script"}