{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\n\nconst aggregate_1 = require(\"../operations/aggregate\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\n\n\nconst kPipeline = Symbol('pipeline');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\n\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n  /** @internal */\n  constructor(client, namespace, pipeline = [], options = {}) {\n    super(client, namespace, options);\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n\n  get pipeline() {\n    return this[kPipeline];\n  }\n\n  clone() {\n    const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.client, this.namespace, this[kPipeline], { ...clonedOptions\n    });\n  }\n\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], { ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: aggregateOperation.server,\n        session,\n        response\n      });\n    });\n  }\n  /** Execute the explain for the cursor */\n\n\n  explain(verbosity) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return (0, execute_operation_1.executeOperation)(_this.client, new aggregate_1.AggregateOperation(_this.namespace, _this[kPipeline], { ..._this[kOptions],\n        ..._this.cursorOptions,\n        explain: verbosity ?? true\n      }));\n    })();\n  }\n\n  group($group) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $group\n    });\n    return this;\n  }\n  /** Add a limit stage to the aggregation pipeline */\n\n\n  limit($limit) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $limit\n    });\n    return this;\n  }\n  /** Add a match stage to the aggregation pipeline */\n\n\n  match($match) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $match\n    });\n    return this;\n  }\n  /** Add an out stage to the aggregation pipeline */\n\n\n  out($out) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $out\n    });\n    return this;\n  }\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n\n\n  project($project) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $project\n    });\n    return this;\n  }\n  /** Add a lookup stage to the aggregation pipeline */\n\n\n  lookup($lookup) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $lookup\n    });\n    return this;\n  }\n  /** Add a redact stage to the aggregation pipeline */\n\n\n  redact($redact) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $redact\n    });\n    return this;\n  }\n  /** Add a skip stage to the aggregation pipeline */\n\n\n  skip($skip) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $skip\n    });\n    return this;\n  }\n  /** Add a sort stage to the aggregation pipeline */\n\n\n  sort($sort) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $sort\n    });\n    return this;\n  }\n  /** Add a unwind stage to the aggregation pipeline */\n\n\n  unwind($unwind) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $unwind\n    });\n    return this;\n  }\n  /** Add a geoNear stage to the aggregation pipeline */\n\n\n  geoNear($geoNear) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $geoNear\n    });\n    return this;\n  }\n\n}\n\nexports.AggregationCursor = AggregationCursor;","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/cursor/aggregation_cursor.js"],"names":["Object","defineProperty","exports","value","AggregationCursor","aggregate_1","require","execute_operation_1","utils_1","abstract_cursor_1","kPipeline","Symbol","kOptions","AbstractCursor","constructor","client","namespace","pipeline","options","clone","clonedOptions","mergeOptions","session","map","transform","_initialize","callback","aggregateOperation","AggregateOperation","cursorOptions","executeOperation","err","response","undefined","server","explain","verbosity","group","$group","assertUninitialized","push","limit","$limit","match","$match","out","$out","project","$project","lookup","$lookup","redact","$redact","skip","$skip","sort","$sort","unwind","$unwind","geoNear","$geoNear"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AggregationCursor = void 0;\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nconst kPipeline = Symbol('pipeline');\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n    /** @internal */\n    constructor(client, namespace, pipeline = [], options = {}) {\n        super(client, namespace, options);\n        this[kPipeline] = pipeline;\n        this[kOptions] = options;\n    }\n    get pipeline() {\n        return this[kPipeline];\n    }\n    clone() {\n        const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);\n        delete clonedOptions.session;\n        return new AggregationCursor(this.client, this.namespace, this[kPipeline], {\n            ...clonedOptions\n        });\n    }\n    map(transform) {\n        return super.map(transform);\n    }\n    /** @internal */\n    _initialize(session, callback) {\n        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {\n            ...this[kOptions],\n            ...this.cursorOptions,\n            session\n        });\n        (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, (err, response) => {\n            if (err || response == null)\n                return callback(err);\n            // TODO: NODE-2882\n            callback(undefined, { server: aggregateOperation.server, session, response });\n        });\n    }\n    /** Execute the explain for the cursor */\n    async explain(verbosity) {\n        return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {\n            ...this[kOptions],\n            ...this.cursorOptions,\n            explain: verbosity ?? true\n        }));\n    }\n    group($group) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $group });\n        return this;\n    }\n    /** Add a limit stage to the aggregation pipeline */\n    limit($limit) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $limit });\n        return this;\n    }\n    /** Add a match stage to the aggregation pipeline */\n    match($match) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $match });\n        return this;\n    }\n    /** Add an out stage to the aggregation pipeline */\n    out($out) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $out });\n        return this;\n    }\n    /**\n     * Add a project stage to the aggregation pipeline\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n     * You should specify a parameterized type to have assertions on your final results.\n     *\n     * @example\n     * ```typescript\n     * // Best way\n     * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * // Flexible way\n     * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n     * ```\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling project,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n     *\n     * // or always use chaining and save the final cursor\n     *\n     * const cursor = coll.aggregate().project<{ a: string }>({\n     *   _id: 0,\n     *   a: { $convert: { input: '$a', to: 'string' }\n     * }});\n     * ```\n     */\n    project($project) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $project });\n        return this;\n    }\n    /** Add a lookup stage to the aggregation pipeline */\n    lookup($lookup) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $lookup });\n        return this;\n    }\n    /** Add a redact stage to the aggregation pipeline */\n    redact($redact) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $redact });\n        return this;\n    }\n    /** Add a skip stage to the aggregation pipeline */\n    skip($skip) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $skip });\n        return this;\n    }\n    /** Add a sort stage to the aggregation pipeline */\n    sort($sort) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $sort });\n        return this;\n    }\n    /** Add a unwind stage to the aggregation pipeline */\n    unwind($unwind) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $unwind });\n        return this;\n    }\n    /** Add a geoNear stage to the aggregation pipeline */\n    geoNear($geoNear) {\n        (0, abstract_cursor_1.assertUninitialized)(this);\n        this[kPipeline].push({ $geoNear });\n        return this;\n    }\n}\nexports.AggregationCursor = AggregationCursor;\n"]},"metadata":{},"sourceType":"script"}