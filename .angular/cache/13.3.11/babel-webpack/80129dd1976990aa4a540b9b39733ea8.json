{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:\\\\dev-projects\\\\APEX\\\\Legalalliance\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst util_1 = require(\"util\");\n\nconst bson_1 = require(\"../../bson\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst providers_1 = require(\"./providers\");\n\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n    this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);\n  }\n\n  prepare(handshakeDoc, authContext) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const cryptoMethod = _this.cryptoMethod;\n      const credentials = authContext.credentials;\n\n      if (!credentials) {\n        throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n      }\n\n      if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n        (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n\n      const nonce = yield _this.randomBytesAsync(24); // store the nonce for later use\n\n      authContext.nonce = nonce;\n      const request = { ...handshakeDoc,\n        speculativeAuthenticate: { ...makeFirstMessage(cryptoMethod, credentials, nonce),\n          db: credentials.source\n        }\n      };\n      return request;\n    })();\n  }\n\n  auth(authContext) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        reauthenticating,\n        response\n      } = authContext;\n\n      if (response?.speculativeAuthenticate && !reauthenticating) {\n        return continueScramConversation(_this2.cryptoMethod, response.speculativeAuthenticate, authContext);\n      }\n\n      return executeScram(_this2.cryptoMethod, authContext);\n    })();\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(_x, _x2) {\n  return _executeScram.apply(this, arguments);\n}\n\nfunction _executeScram() {\n  _executeScram = _asyncToGenerator(function* (cryptoMethod, authContext) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n\n    if (!credentials) {\n      throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n\n    if (!authContext.nonce) {\n      throw new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\n    }\n\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n    const response = yield connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined);\n    yield continueScramConversation(cryptoMethod, response, authContext);\n  });\n  return _executeScram.apply(this, arguments);\n}\n\nfunction continueScramConversation(_x3, _x4, _x5) {\n  return _continueScramConversation.apply(this, arguments);\n}\n\nfunction _continueScramConversation() {\n  _continueScramConversation = _asyncToGenerator(function* (cryptoMethod, response, authContext) {\n    const connection = authContext.connection;\n    const credentials = authContext.credentials;\n\n    if (!credentials) {\n      throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n\n    if (!authContext.nonce) {\n      throw new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\n    }\n\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const username = cleanUsername(credentials.username);\n    const password = credentials.password;\n    let processedPassword;\n\n    if (cryptoMethod === 'sha256') {\n      processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);\n    } else {\n      processedPassword = passwordDigest(username, password);\n    }\n\n    const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n    const dict = parsePayload(payload.value());\n    const iterations = parseInt(dict.i, 10);\n\n    if (iterations && iterations < 4096) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);\n    }\n\n    const salt = dict.s;\n    const rnonce = dict.r;\n\n    if (rnonce.startsWith('nonce')) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);\n    } // Set up start of proof\n\n\n    const withoutProof = `c=biws,r=${rnonce}`;\n    const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n    const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n    const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n    const storedKey = H(cryptoMethod, clientKey);\n    const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n    const clientProof = `p=${xor(clientKey, clientSignature)}`;\n    const clientFinal = [withoutProof, clientProof].join(',');\n    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n    const saslContinueCmd = {\n      saslContinue: 1,\n      conversationId: response.conversationId,\n      payload: new bson_1.Binary(Buffer.from(clientFinal))\n    };\n    const r = yield connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined);\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      throw new error_1.MongoRuntimeError('Server returned an invalid signature');\n    }\n\n    if (r.done !== false) {\n      // If the server sends r.done === true we can save one RTT\n      return;\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    yield connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined);\n  });\n  return _continueScramConversation.apply(this, arguments);\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  let md5;\n\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n\n    throw err;\n  }\n\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n\n}\n\nexports.ScramSHA1 = ScramSHA1;\n\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n\n}\n\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"sources":["D:/dev-projects/APEX/Legalalliance/node_modules/mongodb/lib/cmap/auth/scram.js"],"names":["Object","defineProperty","exports","value","ScramSHA256","ScramSHA1","crypto","require","util_1","bson_1","deps_1","error_1","utils_1","auth_provider_1","providers_1","ScramSHA","AuthProvider","constructor","cryptoMethod","randomBytesAsync","promisify","randomBytes","prepare","handshakeDoc","authContext","credentials","MongoMissingCredentialsError","saslprep","emitWarning","nonce","request","speculativeAuthenticate","makeFirstMessage","db","source","auth","reauthenticating","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","Buffer","concat","from","toString","mechanism","AuthMechanism","MONGODB_SCRAM_SHA1","MONGODB_SCRAM_SHA256","saslStart","payload","Binary","autoAuthorize","options","skipEmptyExchange","connection","MongoInvalidArgumentError","saslStartCmd","commandAsync","ns","undefined","password","processedPassword","passwordDigest","isBuffer","dict","parsePayload","iterations","parseInt","i","MongoRuntimeError","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","err","getFips","Error","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","result"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nconst crypto = require(\"crypto\");\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"../../bson\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst providers_1 = require(\"./providers\");\nclass ScramSHA extends auth_provider_1.AuthProvider {\n    constructor(cryptoMethod) {\n        super();\n        this.cryptoMethod = cryptoMethod || 'sha1';\n        this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);\n    }\n    async prepare(handshakeDoc, authContext) {\n        const cryptoMethod = this.cryptoMethod;\n        const credentials = authContext.credentials;\n        if (!credentials) {\n            throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n        }\n        if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n            (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n        }\n        const nonce = await this.randomBytesAsync(24);\n        // store the nonce for later use\n        authContext.nonce = nonce;\n        const request = {\n            ...handshakeDoc,\n            speculativeAuthenticate: {\n                ...makeFirstMessage(cryptoMethod, credentials, nonce),\n                db: credentials.source\n            }\n        };\n        return request;\n    }\n    async auth(authContext) {\n        const { reauthenticating, response } = authContext;\n        if (response?.speculativeAuthenticate && !reauthenticating) {\n            return continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);\n        }\n        return executeScram(this.cryptoMethod, authContext);\n    }\n}\nfunction cleanUsername(username) {\n    return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return Buffer.concat([\n        Buffer.from('n=', 'utf8'),\n        Buffer.from(username, 'utf8'),\n        Buffer.from(',r=', 'utf8'),\n        Buffer.from(nonce.toString('base64'), 'utf8')\n    ]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n    const username = cleanUsername(credentials.username);\n    const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return {\n        saslStart: 1,\n        mechanism,\n        payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n        autoAuthorize: 1,\n        options: { skipEmptyExchange: true }\n    };\n}\nasync function executeScram(cryptoMethod, authContext) {\n    const { connection, credentials } = authContext;\n    if (!credentials) {\n        throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    if (!authContext.nonce) {\n        throw new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n    const response = await connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined);\n    await continueScramConversation(cryptoMethod, response, authContext);\n}\nasync function continueScramConversation(cryptoMethod, response, authContext) {\n    const connection = authContext.connection;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n        throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    if (!authContext.nonce) {\n        throw new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const username = cleanUsername(credentials.username);\n    const password = credentials.password;\n    let processedPassword;\n    if (cryptoMethod === 'sha256') {\n        processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);\n    }\n    else {\n        processedPassword = passwordDigest(username, password);\n    }\n    const payload = Buffer.isBuffer(response.payload)\n        ? new bson_1.Binary(response.payload)\n        : response.payload;\n    const dict = parsePayload(payload.value());\n    const iterations = parseInt(dict.i, 10);\n    if (iterations && iterations < 4096) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);\n    }\n    const salt = dict.s;\n    const rnonce = dict.r;\n    if (rnonce.startsWith('nonce')) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);\n    }\n    // Set up start of proof\n    const withoutProof = `c=biws,r=${rnonce}`;\n    const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n    const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n    const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n    const storedKey = H(cryptoMethod, clientKey);\n    const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n    const clientProof = `p=${xor(clientKey, clientSignature)}`;\n    const clientFinal = [withoutProof, clientProof].join(',');\n    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n    const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: response.conversationId,\n        payload: new bson_1.Binary(Buffer.from(clientFinal))\n    };\n    const r = await connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined);\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n        throw new error_1.MongoRuntimeError('Server returned an invalid signature');\n    }\n    if (r.done !== false) {\n        // If the server sends r.done === true we can save one RTT\n        return;\n    }\n    const retrySaslContinueCmd = {\n        saslContinue: 1,\n        conversationId: r.conversationId,\n        payload: Buffer.alloc(0)\n    };\n    await connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined);\n}\nfunction parsePayload(payload) {\n    const dict = {};\n    const parts = payload.split(',');\n    for (let i = 0; i < parts.length; i++) {\n        const valueParts = parts[i].split('=');\n        dict[valueParts[0]] = valueParts[1];\n    }\n    return dict;\n}\nfunction passwordDigest(username, password) {\n    if (typeof username !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Username must be a string');\n    }\n    if (typeof password !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Password must be a string');\n    }\n    if (password.length === 0) {\n        throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n    }\n    let md5;\n    try {\n        md5 = crypto.createHash('md5');\n    }\n    catch (err) {\n        if (crypto.getFips()) {\n            // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n            // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n            throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n        }\n        throw err;\n    }\n    md5.update(`${username}:mongo:${password}`, 'utf8');\n    return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n    if (!Buffer.isBuffer(a)) {\n        a = Buffer.from(a);\n    }\n    if (!Buffer.isBuffer(b)) {\n        b = Buffer.from(b);\n    }\n    const length = Math.max(a.length, b.length);\n    const res = [];\n    for (let i = 0; i < length; i += 1) {\n        res.push(a[i] ^ b[i]);\n    }\n    return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n    return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n    return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n    _hiCache = {};\n    _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n    sha256: 32,\n    sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n    // omit the work if already generated\n    const key = [data, salt.toString('base64'), iterations].join('_');\n    if (_hiCache[key] != null) {\n        return _hiCache[key];\n    }\n    // generate the salt\n    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n    // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n    if (_hiCacheCount >= 200) {\n        _hiCachePurge();\n    }\n    _hiCache[key] = saltedData;\n    _hiCacheCount += 1;\n    return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n    if (lhs.length !== rhs.length) {\n        return false;\n    }\n    if (typeof crypto.timingSafeEqual === 'function') {\n        return crypto.timingSafeEqual(lhs, rhs);\n    }\n    let result = 0;\n    for (let i = 0; i < lhs.length; i++) {\n        result |= lhs[i] ^ rhs[i];\n    }\n    return result === 0;\n}\nclass ScramSHA1 extends ScramSHA {\n    constructor() {\n        super('sha1');\n    }\n}\nexports.ScramSHA1 = ScramSHA1;\nclass ScramSHA256 extends ScramSHA {\n    constructor() {\n        super('sha256');\n    }\n}\nexports.ScramSHA256 = ScramSHA256;\n"]},"metadata":{},"sourceType":"script"}